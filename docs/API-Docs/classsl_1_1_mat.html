<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Roboy Vision: Mat Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Roboy Vision
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>sl</b></li><li class="navelem"><a class="el" href="classsl_1_1_mat.html">Mat</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">Mat Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> class can handle multiple matrix format from 1 to 4 channels, with different value types (float or uchar), and can be stored CPU and/or GPU side. <br />
<br />
 <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">sl::Mat</a> is defined in a row-major order: <br />
 - It means that, in the image buffer, the entire first row is stored first, followed by the entire second row, and so on. <br />
<br />
 The CPU and GPU buffer aren't automatically synchronized for performance reasons, you can use <a class="el" href="classsl_1_1_mat.html#a61db709e04e1cd353b852514d280a99f" title="Downloads data from DEVICE (GPU) to HOST (CPU), if possible. ">Mat::updateCPUfromGPU</a> / <a class="el" href="classsl_1_1_mat.html#afa6aadc30f3bc8df5e99850ff7e6cc4b" title="Uploads data from HOST (CPU) to DEVICE (GPU), if possible. ">Mat::updateGPUfromCPU</a> to do it. <br />
<br />
 If you are using the GPU side of the <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> object, you need to make sure to call <a class="el" href="classsl_1_1_mat.html#a55a46a4da55dbe0d01bf21b8b0792280" title="Free the owned memory. ">sl::Mat::free()</a> before destroying the <a class="el" href="classsl_1_1_camera.html" title="The main class to use the ZED camera. ">sl::Camera</a> object. <br />
 The destruction of the <a class="el" href="classsl_1_1_camera.html" title="The main class to use the ZED camera. ">sl::Camera</a> object delete the CUDA context needed to free the GPU <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> memory.  
 <a href="classsl_1_1_mat.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_core_8hpp_source.html">Core.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a13e4639b574685e1d9162ed953e607ed"><td class="memItemLeft" align="right" valign="top"><a id="a13e4639b574685e1d9162ed953e607ed"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#a13e4639b574685e1d9162ed953e607ed">Mat</a> ()</td></tr>
<tr class="memdesc:a13e4639b574685e1d9162ed953e607ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">empty <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> default constructor. <br /></td></tr>
<tr class="separator:a13e4639b574685e1d9162ed953e607ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad430a928c3b9036f27963d2408602749"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#ad430a928c3b9036f27963d2408602749">Mat</a> (size_t width, size_t height, <a class="el" href="group___enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a> mat_type, <a class="el" href="group___enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a> memory_type=MEM_CPU)</td></tr>
<tr class="memdesc:ad430a928c3b9036f27963d2408602749"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> constructor.  <a href="#ad430a928c3b9036f27963d2408602749">More...</a><br /></td></tr>
<tr class="separator:ad430a928c3b9036f27963d2408602749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4c88b51cfa492f0d0acb4055e53803"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#a3e4c88b51cfa492f0d0acb4055e53803">Mat</a> (size_t width, size_t height, <a class="el" href="group___enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a> mat_type, sl::uchar1 *ptr, size_t step, <a class="el" href="group___enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a> memory_type=MEM_CPU)</td></tr>
<tr class="memdesc:a3e4c88b51cfa492f0d0acb4055e53803"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> constructor from an existing data pointer.  <a href="#a3e4c88b51cfa492f0d0acb4055e53803">More...</a><br /></td></tr>
<tr class="separator:a3e4c88b51cfa492f0d0acb4055e53803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577e41f91b8f918baed38d25da9ea63c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#a577e41f91b8f918baed38d25da9ea63c">Mat</a> (size_t width, size_t height, <a class="el" href="group___enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a> mat_type, sl::uchar1 *ptr_cpu, size_t step_cpu, sl::uchar1 *ptr_gpu, size_t step_gpu)</td></tr>
<tr class="memdesc:a577e41f91b8f918baed38d25da9ea63c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> constructor from two existing data pointers, CPU and GPU.  <a href="#a577e41f91b8f918baed38d25da9ea63c">More...</a><br /></td></tr>
<tr class="separator:a577e41f91b8f918baed38d25da9ea63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413ea3f154ef776e53bf6afec905327a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#a413ea3f154ef776e53bf6afec905327a">Mat</a> (<a class="el" href="structsl_1_1_resolution.html">sl::Resolution</a> resolution, <a class="el" href="group___enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a> mat_type, <a class="el" href="group___enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a> memory_type=MEM_CPU)</td></tr>
<tr class="memdesc:a413ea3f154ef776e53bf6afec905327a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> constructor.  <a href="#a413ea3f154ef776e53bf6afec905327a">More...</a><br /></td></tr>
<tr class="separator:a413ea3f154ef776e53bf6afec905327a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b889acf09ca25035b6e7fba91c083c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#a50b889acf09ca25035b6e7fba91c083c">Mat</a> (<a class="el" href="structsl_1_1_resolution.html">sl::Resolution</a> resolution, <a class="el" href="group___enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a> mat_type, sl::uchar1 *ptr, size_t step, <a class="el" href="group___enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a> memory_type=MEM_CPU)</td></tr>
<tr class="memdesc:a50b889acf09ca25035b6e7fba91c083c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> constructor from an existing data pointer.  <a href="#a50b889acf09ca25035b6e7fba91c083c">More...</a><br /></td></tr>
<tr class="separator:a50b889acf09ca25035b6e7fba91c083c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae357f076460a85a02e4b314c812bddd1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#ae357f076460a85a02e4b314c812bddd1">Mat</a> (<a class="el" href="structsl_1_1_resolution.html">sl::Resolution</a> resolution, <a class="el" href="group___enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a> mat_type, sl::uchar1 *ptr_cpu, size_t step_cpu, sl::uchar1 *ptr_gpu, size_t step_gpu)</td></tr>
<tr class="memdesc:ae357f076460a85a02e4b314c812bddd1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> constructor from two existing data pointers, CPU and GPU.  <a href="#ae357f076460a85a02e4b314c812bddd1">More...</a><br /></td></tr>
<tr class="separator:ae357f076460a85a02e4b314c812bddd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a9abbeab47a716e9103f2ce5d9a6d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#aa0a9abbeab47a716e9103f2ce5d9a6d6">Mat</a> (const <a class="el" href="classsl_1_1_mat.html">sl::Mat</a> &amp;mat)</td></tr>
<tr class="memdesc:aa0a9abbeab47a716e9103f2ce5d9a6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> constructor by copy (deep copy).  <a href="#aa0a9abbeab47a716e9103f2ce5d9a6d6">More...</a><br /></td></tr>
<tr class="separator:aa0a9abbeab47a716e9103f2ce5d9a6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758f0735ff6b2111adda36d7289d08b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#a758f0735ff6b2111adda36d7289d08b4">alloc</a> (size_t width, size_t height, <a class="el" href="group___enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a> mat_type, <a class="el" href="group___enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a> memory_type=MEM_CPU)</td></tr>
<tr class="memdesc:a758f0735ff6b2111adda36d7289d08b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates the <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> memory.  <a href="#a758f0735ff6b2111adda36d7289d08b4">More...</a><br /></td></tr>
<tr class="separator:a758f0735ff6b2111adda36d7289d08b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb82043e1f972dd11911bec6c258a3ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#aeb82043e1f972dd11911bec6c258a3ee">alloc</a> (<a class="el" href="structsl_1_1_resolution.html">sl::Resolution</a> resolution, <a class="el" href="group___enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a> mat_type, <a class="el" href="group___enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a> memory_type=MEM_CPU)</td></tr>
<tr class="memdesc:aeb82043e1f972dd11911bec6c258a3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates the <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> memory.  <a href="#aeb82043e1f972dd11911bec6c258a3ee">More...</a><br /></td></tr>
<tr class="separator:aeb82043e1f972dd11911bec6c258a3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85825bed2f9a04a95dcee2b84d96fd5e"><td class="memItemLeft" align="right" valign="top"><a id="a85825bed2f9a04a95dcee2b84d96fd5e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#a85825bed2f9a04a95dcee2b84d96fd5e">~Mat</a> ()</td></tr>
<tr class="memdesc:a85825bed2f9a04a95dcee2b84d96fd5e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> destructor. This function calls <a class="el" href="classsl_1_1_mat.html#a55a46a4da55dbe0d01bf21b8b0792280" title="Free the owned memory. ">Mat::free</a> to release owned memory. <br /></td></tr>
<tr class="separator:a85825bed2f9a04a95dcee2b84d96fd5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a46a4da55dbe0d01bf21b8b0792280"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#a55a46a4da55dbe0d01bf21b8b0792280">free</a> (<a class="el" href="group___enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a> memory_type=MEM_CPU|MEM_GPU)</td></tr>
<tr class="memdesc:a55a46a4da55dbe0d01bf21b8b0792280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the owned memory.  <a href="#a55a46a4da55dbe0d01bf21b8b0792280">More...</a><br /></td></tr>
<tr class="separator:a55a46a4da55dbe0d01bf21b8b0792280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35dbb18591a2dcba489f153dfe7d893"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsl_1_1_mat.html">Mat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#af35dbb18591a2dcba489f153dfe7d893">operator=</a> (const <a class="el" href="classsl_1_1_mat.html">Mat</a> &amp;that)</td></tr>
<tr class="memdesc:af35dbb18591a2dcba489f153dfe7d893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a shallow copy. <br />
 This function doesn't copy the data array, it only copies the pointer.  <a href="#af35dbb18591a2dcba489f153dfe7d893">More...</a><br /></td></tr>
<tr class="separator:af35dbb18591a2dcba489f153dfe7d893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61db709e04e1cd353b852514d280a99f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#a61db709e04e1cd353b852514d280a99f">updateCPUfromGPU</a> ()</td></tr>
<tr class="memdesc:a61db709e04e1cd353b852514d280a99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downloads data from DEVICE (GPU) to HOST (CPU), if possible.  <a href="#a61db709e04e1cd353b852514d280a99f">More...</a><br /></td></tr>
<tr class="separator:a61db709e04e1cd353b852514d280a99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6aadc30f3bc8df5e99850ff7e6cc4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#afa6aadc30f3bc8df5e99850ff7e6cc4b">updateGPUfromCPU</a> ()</td></tr>
<tr class="memdesc:afa6aadc30f3bc8df5e99850ff7e6cc4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uploads data from HOST (CPU) to DEVICE (GPU), if possible.  <a href="#afa6aadc30f3bc8df5e99850ff7e6cc4b">More...</a><br /></td></tr>
<tr class="separator:afa6aadc30f3bc8df5e99850ff7e6cc4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a8fd8d9763ffc498c903da4a1b411d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#ae8a8fd8d9763ffc498c903da4a1b411d">copyTo</a> (<a class="el" href="classsl_1_1_mat.html">Mat</a> &amp;dst, <a class="el" href="group___enumerations.html#ga6053bda451d8ca289b3e443377cfc004">COPY_TYPE</a> cpyType=COPY_TYPE_CPU_CPU) const</td></tr>
<tr class="memdesc:ae8a8fd8d9763ffc498c903da4a1b411d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data an other <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> (deep copy).  <a href="#ae8a8fd8d9763ffc498c903da4a1b411d">More...</a><br /></td></tr>
<tr class="separator:ae8a8fd8d9763ffc498c903da4a1b411d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb25ebe04ae0193f13d34a77089b6b04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#aeb25ebe04ae0193f13d34a77089b6b04">setFrom</a> (const <a class="el" href="classsl_1_1_mat.html">Mat</a> &amp;src, <a class="el" href="group___enumerations.html#ga6053bda451d8ca289b3e443377cfc004">COPY_TYPE</a> cpyType=COPY_TYPE_CPU_CPU)</td></tr>
<tr class="memdesc:aeb25ebe04ae0193f13d34a77089b6b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from an other <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> (deep copy).  <a href="#aeb25ebe04ae0193f13d34a77089b6b04">More...</a><br /></td></tr>
<tr class="separator:aeb25ebe04ae0193f13d34a77089b6b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863ea6ea6124438c6652336d357bffec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#a863ea6ea6124438c6652336d357bffec">read</a> (const char *filePath)</td></tr>
<tr class="memdesc:a863ea6ea6124438c6652336d357bffec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an image from a file (only if sl::MEM_CPU is available on the current <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">sl::Mat</a>).  <a href="#a863ea6ea6124438c6652336d357bffec">More...</a><br /></td></tr>
<tr class="separator:a863ea6ea6124438c6652336d357bffec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acf6247c440dcd777d3da7e55bee2fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#a7acf6247c440dcd777d3da7e55bee2fd">write</a> (const char *filePath)</td></tr>
<tr class="memdesc:a7acf6247c440dcd777d3da7e55bee2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">sl::Mat</a> (only if sl::MEM_CPU is available) into a file as an image.  <a href="#a7acf6247c440dcd777d3da7e55bee2fd">More...</a><br /></td></tr>
<tr class="separator:a7acf6247c440dcd777d3da7e55bee2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af000d3beacf03312363f52b1d8825ccc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af000d3beacf03312363f52b1d8825ccc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group___enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#af000d3beacf03312363f52b1d8825ccc">setTo</a> (T value, <a class="el" href="group___enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a> memory_type=MEM_CPU)</td></tr>
<tr class="memdesc:af000d3beacf03312363f52b1d8825ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> with the given value.  <a href="#af000d3beacf03312363f52b1d8825ccc">More...</a><br /></td></tr>
<tr class="separator:af000d3beacf03312363f52b1d8825ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fb42724066753c016b9b86145da01f"><td class="memTemplParams" colspan="2">template&lt;typename N &gt; </td></tr>
<tr class="memitem:a79fb42724066753c016b9b86145da01f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group___enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#a79fb42724066753c016b9b86145da01f">setValue</a> (size_t x, size_t y, N value, <a class="el" href="group___enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a> memory_type=MEM_CPU)</td></tr>
<tr class="memdesc:a79fb42724066753c016b9b86145da01f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a value to a specific point in the matrix.  <a href="#a79fb42724066753c016b9b86145da01f">More...</a><br /></td></tr>
<tr class="separator:a79fb42724066753c016b9b86145da01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315d1c055fd9aa272dd10e5e750710aa"><td class="memTemplParams" colspan="2">template&lt;typename N &gt; </td></tr>
<tr class="memitem:a315d1c055fd9aa272dd10e5e750710aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group___enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#a315d1c055fd9aa272dd10e5e750710aa">getValue</a> (size_t x, size_t y, N *value, <a class="el" href="group___enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a> memory_type=MEM_CPU)</td></tr>
<tr class="memdesc:a315d1c055fd9aa272dd10e5e750710aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of a specific point in the matrix.  <a href="#a315d1c055fd9aa272dd10e5e750710aa">More...</a><br /></td></tr>
<tr class="separator:a315d1c055fd9aa272dd10e5e750710aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52477d2dcc839fafe8a8ee5026a2621"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#aa52477d2dcc839fafe8a8ee5026a2621">getWidth</a> () const</td></tr>
<tr class="separator:aa52477d2dcc839fafe8a8ee5026a2621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb56064ac644b85442a915c9fdf19f8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#afdb56064ac644b85442a915c9fdf19f8">getHeight</a> () const</td></tr>
<tr class="separator:afdb56064ac644b85442a915c9fdf19f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2095803fee1da82ac47fc910093d06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsl_1_1_resolution.html">Resolution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#a9e2095803fee1da82ac47fc910093d06">getResolution</a> () const</td></tr>
<tr class="separator:a9e2095803fee1da82ac47fc910093d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a98e29bec33645a8136249a89ec641"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#a90a98e29bec33645a8136249a89ec641">getChannels</a> () const</td></tr>
<tr class="separator:a90a98e29bec33645a8136249a89ec641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6673fd67d68f40f36677ed6945aa25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#a1b6673fd67d68f40f36677ed6945aa25">getDataType</a> () const</td></tr>
<tr class="separator:a1b6673fd67d68f40f36677ed6945aa25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91472e3702165e932795750d0951c3b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#a91472e3702165e932795750d0951c3b0">getMemoryType</a> () const</td></tr>
<tr class="separator:a91472e3702165e932795750d0951c3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2158929ed36ce9fe0e4290353530c0c1"><td class="memTemplParams" colspan="2">template&lt;typename N &gt; </td></tr>
<tr class="memitem:a2158929ed36ce9fe0e4290353530c0c1"><td class="memTemplItemLeft" align="right" valign="top">N *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#a2158929ed36ce9fe0e4290353530c0c1">getPtr</a> (<a class="el" href="group___enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a> memory_type=MEM_CPU)</td></tr>
<tr class="separator:a2158929ed36ce9fe0e4290353530c0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae56a797f7186d43b6ef3e6d9d65769"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#a7ae56a797f7186d43b6ef3e6d9d65769">getStepBytes</a> (<a class="el" href="group___enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a> memory_type=MEM_CPU)</td></tr>
<tr class="separator:a7ae56a797f7186d43b6ef3e6d9d65769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d94eae6378ea2432c91f01661081f29"><td class="memTemplParams" colspan="2">template&lt;typename N &gt; </td></tr>
<tr class="memitem:a3d94eae6378ea2432c91f01661081f29"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#a3d94eae6378ea2432c91f01661081f29">getStep</a> (<a class="el" href="group___enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a> memory_type=MEM_CPU)</td></tr>
<tr class="separator:a3d94eae6378ea2432c91f01661081f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadad9f8295d68405d4f4c14129829add"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#aadad9f8295d68405d4f4c14129829add">getStep</a> (<a class="el" href="group___enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a> memory_type=MEM_CPU)</td></tr>
<tr class="separator:aadad9f8295d68405d4f4c14129829add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12707842412452a97ad32ed401e71dae"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#a12707842412452a97ad32ed401e71dae">getPixelBytes</a> ()</td></tr>
<tr class="separator:a12707842412452a97ad32ed401e71dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e83baf8150879f1343401cb2bbf5fa2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#a2e83baf8150879f1343401cb2bbf5fa2">getWidthBytes</a> ()</td></tr>
<tr class="separator:a2e83baf8150879f1343401cb2bbf5fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cfac867c035e4e665327c72d75b41ce"><td class="memItemLeft" align="right" valign="top">sl::String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#a9cfac867c035e4e665327c72d75b41ce">getInfos</a> ()</td></tr>
<tr class="separator:a9cfac867c035e4e665327c72d75b41ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b57761501df8a7b87694ffdaf065434"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#a0b57761501df8a7b87694ffdaf065434">isInit</a> ()</td></tr>
<tr class="separator:a0b57761501df8a7b87694ffdaf065434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf86c6861743e4ea68d6505a4d255d0e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#abf86c6861743e4ea68d6505a4d255d0e">isMemoryOwner</a> ()</td></tr>
<tr class="separator:abf86c6861743e4ea68d6505a4d255d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e97633eb43ea134f0b9f48ed4e533cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1_mat.html#a1e97633eb43ea134f0b9f48ed4e533cb">clone</a> (const <a class="el" href="classsl_1_1_mat.html">Mat</a> &amp;src)</td></tr>
<tr class="memdesc:a1e97633eb43ea134f0b9f48ed4e533cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicates <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> by copy (deep copy).  <a href="#a1e97633eb43ea134f0b9f48ed4e533cb">More...</a><br /></td></tr>
<tr class="separator:a1e97633eb43ea134f0b9f48ed4e533cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:ae91eebfb22e45be6b4ceee466f3d5a16"><td class="memItemLeft" align="right" valign="top"><a id="ae91eebfb22e45be6b4ceee466f3d5a16"></a>
sl::String&#160;</td><td class="memItemRight" valign="bottom"><b>name</b></td></tr>
<tr class="separator:ae91eebfb22e45be6b4ceee466f3d5a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f078684998b83967d507d0f453f454"><td class="memItemLeft" align="right" valign="top"><a id="ab3f078684998b83967d507d0f453f454"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>verbose</b> = false</td></tr>
<tr class="separator:ab3f078684998b83967d507d0f453f454"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> class can handle multiple matrix format from 1 to 4 channels, with different value types (float or uchar), and can be stored CPU and/or GPU side. <br />
<br />
 <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">sl::Mat</a> is defined in a row-major order: <br />
 - It means that, in the image buffer, the entire first row is stored first, followed by the entire second row, and so on. <br />
<br />
 The CPU and GPU buffer aren't automatically synchronized for performance reasons, you can use <a class="el" href="classsl_1_1_mat.html#a61db709e04e1cd353b852514d280a99f" title="Downloads data from DEVICE (GPU) to HOST (CPU), if possible. ">Mat::updateCPUfromGPU</a> / <a class="el" href="classsl_1_1_mat.html#afa6aadc30f3bc8df5e99850ff7e6cc4b" title="Uploads data from HOST (CPU) to DEVICE (GPU), if possible. ">Mat::updateGPUfromCPU</a> to do it. <br />
<br />
 If you are using the GPU side of the <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> object, you need to make sure to call <a class="el" href="classsl_1_1_mat.html#a55a46a4da55dbe0d01bf21b8b0792280" title="Free the owned memory. ">sl::Mat::free()</a> before destroying the <a class="el" href="classsl_1_1_camera.html" title="The main class to use the ZED camera. ">sl::Camera</a> object. <br />
 The destruction of the <a class="el" href="classsl_1_1_camera.html" title="The main class to use the ZED camera. ">sl::Camera</a> object delete the CUDA context needed to free the GPU <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> memory. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad430a928c3b9036f27963d2408602749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad430a928c3b9036f27963d2408602749">&#9670;&nbsp;</a></span>Mat() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsl_1_1_mat.html">Mat</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a>&#160;</td>
          <td class="paramname"><em>mat_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a>&#160;</td>
          <td class="paramname"><em>memory_type</em> = <code>MEM_CPU</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>: width of the matrix in pixels. </td></tr>
    <tr><td class="paramname">height</td><td>: height of the matrix in pixels. </td></tr>
    <tr><td class="paramname">mat_type</td><td>: the type of the matrix (sl::MAT_TYPE_32F_C1,sl::MAT_TYPE_8U_C4...) </td></tr>
    <tr><td class="paramname">memory_type</td><td>: defines where the buffer will be stored. (sl::MEM_CPU and/or sl::MEM_GPU). This function directly allocates the requested memory. It calls <a class="el" href="classsl_1_1_mat.html#a758f0735ff6b2111adda36d7289d08b4" title="Allocates the Mat memory. ">Mat::alloc</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e4c88b51cfa492f0d0acb4055e53803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e4c88b51cfa492f0d0acb4055e53803">&#9670;&nbsp;</a></span>Mat() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsl_1_1_mat.html">Mat</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a>&#160;</td>
          <td class="paramname"><em>mat_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sl::uchar1 *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a>&#160;</td>
          <td class="paramname"><em>memory_type</em> = <code>MEM_CPU</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> constructor from an existing data pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>: width of the matrix in pixels. </td></tr>
    <tr><td class="paramname">height</td><td>: height of the matrix in pixels. </td></tr>
    <tr><td class="paramname">mat_type</td><td>: the type of the matrix (sl::MAT_TYPE_32F_C1,sl::MAT_TYPE_8U_C4...) </td></tr>
    <tr><td class="paramname">ptr</td><td>: pointer to the data array. (CPU or GPU). </td></tr>
    <tr><td class="paramname">step</td><td>: step of the data array. (the Bytes size of one pixel row) </td></tr>
    <tr><td class="paramname">memory_type</td><td>: defines where the buffer will be stored. (sl::MEM_CPU and/or sl::MEM_GPU). This function doesn't allocate the memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a577e41f91b8f918baed38d25da9ea63c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577e41f91b8f918baed38d25da9ea63c">&#9670;&nbsp;</a></span>Mat() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsl_1_1_mat.html">Mat</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a>&#160;</td>
          <td class="paramname"><em>mat_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sl::uchar1 *&#160;</td>
          <td class="paramname"><em>ptr_cpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>step_cpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sl::uchar1 *&#160;</td>
          <td class="paramname"><em>ptr_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>step_gpu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> constructor from two existing data pointers, CPU and GPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>: width of the matrix in pixels. </td></tr>
    <tr><td class="paramname">height</td><td>: height of the matrix in pixels. </td></tr>
    <tr><td class="paramname">mat_type</td><td>: the type of the matrix (sl::MAT_TYPE_32F_C1,sl::MAT_TYPE_8U_C4...) </td></tr>
    <tr><td class="paramname">ptr_cpu</td><td>: CPU pointer to the data array. </td></tr>
    <tr><td class="paramname">step_cpu</td><td>: step of the CPU data array. (the Bytes size of one pixel row) </td></tr>
    <tr><td class="paramname">ptr_gpu</td><td>: GPU pointer to the data array. </td></tr>
    <tr><td class="paramname">step_gpu</td><td>: step of the GPU data array. (the Bytes size of one pixel row) This function doesn't allocate the memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a413ea3f154ef776e53bf6afec905327a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413ea3f154ef776e53bf6afec905327a">&#9670;&nbsp;</a></span>Mat() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsl_1_1_mat.html">Mat</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsl_1_1_resolution.html">sl::Resolution</a>&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a>&#160;</td>
          <td class="paramname"><em>mat_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a>&#160;</td>
          <td class="paramname"><em>memory_type</em> = <code>MEM_CPU</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolution</td><td>: the size of the matrix in pixels. </td></tr>
    <tr><td class="paramname">mat_type</td><td>: the type of the matrix (sl::MAT_TYPE_32F_C1,sl::MAT_TYPE_8U_C4...) </td></tr>
    <tr><td class="paramname">memory_type</td><td>: defines where the buffer will be stored. (sl::MEM_CPU and/or sl::MEM_GPU). This function directly allocates the requested memory. It calls <a class="el" href="classsl_1_1_mat.html#a758f0735ff6b2111adda36d7289d08b4" title="Allocates the Mat memory. ">Mat::alloc</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50b889acf09ca25035b6e7fba91c083c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b889acf09ca25035b6e7fba91c083c">&#9670;&nbsp;</a></span>Mat() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsl_1_1_mat.html">Mat</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsl_1_1_resolution.html">sl::Resolution</a>&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a>&#160;</td>
          <td class="paramname"><em>mat_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sl::uchar1 *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a>&#160;</td>
          <td class="paramname"><em>memory_type</em> = <code>MEM_CPU</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> constructor from an existing data pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolution</td><td>: the size of the matrix in pixels. </td></tr>
    <tr><td class="paramname">mat_type</td><td>: the type of the matrix (sl::MAT_TYPE_32F_C1,sl::MAT_TYPE_8U_C4...) </td></tr>
    <tr><td class="paramname">ptr</td><td>: pointer to the data array. (CPU or GPU). </td></tr>
    <tr><td class="paramname">step</td><td>: step of the data array. (the Bytes size of one pixel row) </td></tr>
    <tr><td class="paramname">memory_type</td><td>: defines where the buffer will be stored. (sl::MEM_CPU and/or sl::MEM_GPU). This function doesn't allocate the memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae357f076460a85a02e4b314c812bddd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae357f076460a85a02e4b314c812bddd1">&#9670;&nbsp;</a></span>Mat() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsl_1_1_mat.html">Mat</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsl_1_1_resolution.html">sl::Resolution</a>&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a>&#160;</td>
          <td class="paramname"><em>mat_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sl::uchar1 *&#160;</td>
          <td class="paramname"><em>ptr_cpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>step_cpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sl::uchar1 *&#160;</td>
          <td class="paramname"><em>ptr_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>step_gpu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> constructor from two existing data pointers, CPU and GPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolution</td><td>: the size of the matrix in pixels. </td></tr>
    <tr><td class="paramname">mat_type</td><td>: the type of the matrix (sl::MAT_TYPE_32F_C1,sl::MAT_TYPE_8U_C4...) </td></tr>
    <tr><td class="paramname">ptr_cpu</td><td>: CPU pointer to the data array. </td></tr>
    <tr><td class="paramname">step_cpu</td><td>: step of the CPU data array. (the Bytes size of one pixel row) </td></tr>
    <tr><td class="paramname">ptr_gpu</td><td>: GPU pointer to the data array. </td></tr>
    <tr><td class="paramname">step_gpu</td><td>: step of the GPU data array. (the Bytes size of one pixel row) This function doesn't allocate the memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0a9abbeab47a716e9103f2ce5d9a6d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a9abbeab47a716e9103f2ce5d9a6d6">&#9670;&nbsp;</a></span>Mat() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsl_1_1_mat.html">Mat</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsl_1_1_mat.html">sl::Mat</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> constructor by copy (deep copy). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>: the reference to the <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">sl::Mat</a> to copy. This function allocates and duplicates the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a758f0735ff6b2111adda36d7289d08b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a758f0735ff6b2111adda36d7289d08b4">&#9670;&nbsp;</a></span>alloc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a>&#160;</td>
          <td class="paramname"><em>mat_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a>&#160;</td>
          <td class="paramname"><em>memory_type</em> = <code>MEM_CPU</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates the <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>: width of the matrix in pixels </td></tr>
    <tr><td class="paramname">height</td><td>: height of the matrix in pixels </td></tr>
    <tr><td class="paramname">mat_type</td><td>: the type of the matrix (sl::MAT_TYPE_32F_C1,sl::MAT_TYPE_8U_C4...) </td></tr>
    <tr><td class="paramname">memory_type</td><td>: defines where the buffer will be stored. (sl::MEM_CPU and/or sl::MEM_GPU). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>It erases previously allocated memory. </dd></dl>

</div>
</div>
<a id="aeb82043e1f972dd11911bec6c258a3ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb82043e1f972dd11911bec6c258a3ee">&#9670;&nbsp;</a></span>alloc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsl_1_1_resolution.html">sl::Resolution</a>&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a>&#160;</td>
          <td class="paramname"><em>mat_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a>&#160;</td>
          <td class="paramname"><em>memory_type</em> = <code>MEM_CPU</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates the <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolution</td><td>: the size of the matrix in pixels. </td></tr>
    <tr><td class="paramname">mat_type</td><td>: the type of the matrix (sl::MAT_TYPE_32F_C1,sl::MAT_TYPE_8U_C4...) </td></tr>
    <tr><td class="paramname">memory_type</td><td>: defines where the buffer will be stored. (sl::MEM_CPU and/or sl::MEM_GPU). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>It erases previously allocated memory. </dd></dl>

</div>
</div>
<a id="a1e97633eb43ea134f0b9f48ed4e533cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e97633eb43ea134f0b9f48ed4e533cb">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsl_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicates <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> by copy (deep copy). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>: the reference to the <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> to copy. This function copies the data array(s), it mark the new <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> as the memory owner. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8a8fd8d9763ffc498c903da4a1b411d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a8fd8d9763ffc498c903da4a1b411d">&#9670;&nbsp;</a></span>copyTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a> copyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsl_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___enumerations.html#ga6053bda451d8ca289b3e443377cfc004">COPY_TYPE</a>&#160;</td>
          <td class="paramname"><em>cpyType</em> = <code>COPY_TYPE_CPU_CPU</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data an other <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> (deep copy). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>: the <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> where the data will be copied. </td></tr>
    <tr><td class="paramname">cpyType</td><td>: specify the memories that will be used for the copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sl::SUCCESS if everything went well, sl::ERROR_CODE_FAILURE otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the destination is not allocated or has a not a compatible sl::MAT_TYPE or <a class="el" href="structsl_1_1_resolution.html" title="Width and height of an array. ">sl::Resolution</a>, current memory is freed and new memory is directly allocated. </dd></dl>

</div>
</div>
<a id="a55a46a4da55dbe0d01bf21b8b0792280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a46a4da55dbe0d01bf21b8b0792280">&#9670;&nbsp;</a></span>free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a>&#160;</td>
          <td class="paramname"><em>memory_type</em> = <code>MEM_CPU|MEM_GPU</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the owned memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memory_type</td><td>: specify whether you want to free the sl::MEM_CPU and/or sl::MEM_GPU memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90a98e29bec33645a8136249a89ec641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90a98e29bec33645a8136249a89ec641">&#9670;&nbsp;</a></span>getChannels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t getChannels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief Returns the number of values stored in one pixel. </p><dl class="section return"><dt>Returns</dt><dd>The number of values in a pixel. </dd></dl>

</div>
</div>
<a id="a1b6673fd67d68f40f36677ed6945aa25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6673fd67d68f40f36677ed6945aa25">&#9670;&nbsp;</a></span>getDataType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a> getDataType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief Returns the format of the matrix. </p><dl class="section return"><dt>Returns</dt><dd>The format of the current <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a>. </dd></dl>

</div>
</div>
<a id="afdb56064ac644b85442a915c9fdf19f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb56064ac644b85442a915c9fdf19f8">&#9670;&nbsp;</a></span>getHeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t getHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief Returns the height of the matrix. </p><dl class="section return"><dt>Returns</dt><dd>The height of the matrix in pixels. </dd></dl>

</div>
</div>
<a id="a9cfac867c035e4e665327c72d75b41ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cfac867c035e4e665327c72d75b41ce">&#9670;&nbsp;</a></span>getInfos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl::String getInfos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>brief Return the informations about the <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> into a sl::String. </p><dl class="section return"><dt>Returns</dt><dd>A string containing the <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> informations. </dd></dl>

</div>
</div>
<a id="a91472e3702165e932795750d0951c3b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91472e3702165e932795750d0951c3b0">&#9670;&nbsp;</a></span>getMemoryType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a> getMemoryType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief Returns the type of memory (CPU and/or GPU). </p><dl class="section return"><dt>Returns</dt><dd>The type of allocated memory. </dd></dl>

</div>
</div>
<a id="a12707842412452a97ad32ed401e71dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12707842412452a97ad32ed401e71dae">&#9670;&nbsp;</a></span>getPixelBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t getPixelBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief Returns the size in bytes of one pixel. </p><dl class="section return"><dt>Returns</dt><dd>The size in bytes of a pixel. </dd></dl>

</div>
</div>
<a id="a2158929ed36ce9fe0e4290353530c0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2158929ed36ce9fe0e4290353530c0c1">&#9670;&nbsp;</a></span>getPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">N* getPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a>&#160;</td>
          <td class="paramname"><em>memory_type</em> = <code>MEM_CPU</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>brief Returns the CPU or GPU data pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memory_type</td><td>: specify whether you want sl::MEM_CPU or sl::MEM_GPU step. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer of the <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> data. </dd></dl>

</div>
</div>
<a id="a9e2095803fee1da82ac47fc910093d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e2095803fee1da82ac47fc910093d06">&#9670;&nbsp;</a></span>getResolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsl_1_1_resolution.html">Resolution</a> getResolution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief Returns the height of the matrix. </p><dl class="section return"><dt>Returns</dt><dd>The height of the matrix in pixels. </dd></dl>

</div>
</div>
<a id="a3d94eae6378ea2432c91f01661081f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d94eae6378ea2432c91f01661081f29">&#9670;&nbsp;</a></span>getStep() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t getStep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a>&#160;</td>
          <td class="paramname"><em>memory_type</em> = <code>MEM_CPU</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief Returns the memory step in number of elements (the number of values in one pixel row). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memory_type</td><td>: specify whether you want sl::MEM_CPU or sl::MEM_GPU step. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The step in number of elements. </dd></dl>

</div>
</div>
<a id="aadad9f8295d68405d4f4c14129829add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadad9f8295d68405d4f4c14129829add">&#9670;&nbsp;</a></span>getStep() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t getStep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a>&#160;</td>
          <td class="paramname"><em>memory_type</em> = <code>MEM_CPU</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief Returns the memory step in number of elements (the number of values in one pixel row). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memory_type</td><td>: specify whether you want sl::MEM_CPU or sl::MEM_GPU step. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The step in number of elements. </dd></dl>

</div>
</div>
<a id="a7ae56a797f7186d43b6ef3e6d9d65769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae56a797f7186d43b6ef3e6d9d65769">&#9670;&nbsp;</a></span>getStepBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t getStepBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a>&#160;</td>
          <td class="paramname"><em>memory_type</em> = <code>MEM_CPU</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief Returns the memory step in Bytes (the Bytes size of one pixel row). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memory_type</td><td>: specify whether you want sl::MEM_CPU or sl::MEM_GPU step. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The step in bytes of the specified memory. </dd></dl>

</div>
</div>
<a id="a315d1c055fd9aa272dd10e5e750710aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315d1c055fd9aa272dd10e5e750710aa">&#9670;&nbsp;</a></span>getValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a> getValue </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a>&#160;</td>
          <td class="paramname"><em>memory_type</em> = <code>MEM_CPU</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of a specific point in the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>: specify the column </td></tr>
    <tr><td class="paramname">y</td><td>: specify the row </td></tr>
    <tr><td class="paramname">memory_type</td><td>: defines which memory should be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sl::SUCCESS if everything went well, sl::ERROR_CODE_FAILURE otherwise. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not efficient for sl::MEM_GPU, use it on sparse data. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is templated for sl::uchar1, sl::uchar2, sl::uchar3, sl::uchar4, sl::float1, sl::float2, sl::float3, sl::float4. </dd></dl>

</div>
</div>
<a id="aa52477d2dcc839fafe8a8ee5026a2621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa52477d2dcc839fafe8a8ee5026a2621">&#9670;&nbsp;</a></span>getWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t getWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief Returns the width of the matrix. </p><dl class="section return"><dt>Returns</dt><dd>The width of the matrix in pixels. </dd></dl>

</div>
</div>
<a id="a2e83baf8150879f1343401cb2bbf5fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e83baf8150879f1343401cb2bbf5fa2">&#9670;&nbsp;</a></span>getWidthBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t getWidthBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief Returns the size in bytes of a row. </p><dl class="section return"><dt>Returns</dt><dd>The size in bytes of a row. </dd></dl>

</div>
</div>
<a id="a0b57761501df8a7b87694ffdaf065434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b57761501df8a7b87694ffdaf065434">&#9670;&nbsp;</a></span>isInit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isInit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief Defines whether the <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> is initialized or not. </p><dl class="section return"><dt>Returns</dt><dd>True if current <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> has been allocated (by the constructor or therefore). </dd></dl>

</div>
</div>
<a id="abf86c6861743e4ea68d6505a4d255d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf86c6861743e4ea68d6505a4d255d0e">&#9670;&nbsp;</a></span>isMemoryOwner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isMemoryOwner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief Returns whether the <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> is the owner of the memory it access. <br />
 If not, the memory won't be freed if the <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> is destroyed. </p><dl class="section return"><dt>Returns</dt><dd>True if the <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> is owning its memory, else false. </dd></dl>

</div>
</div>
<a id="af35dbb18591a2dcba489f153dfe7d893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35dbb18591a2dcba489f153dfe7d893">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsl_1_1_mat.html">Mat</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsl_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a shallow copy. <br />
 This function doesn't copy the data array, it only copies the pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>: the <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">sl::Mat</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">sl::Mat</a> object which point to the same data as that. </dd></dl>

</div>
</div>
<a id="a863ea6ea6124438c6652336d357bffec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a863ea6ea6124438c6652336d357bffec">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a> read </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an image from a file (only if sl::MEM_CPU is available on the current <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">sl::Mat</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td>: file path including the name and extension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sl::SUCCESS if everything went well, sl::ERROR_CODE_FAILURE otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Supported sl::MAT_TYPE are : sl::MAT_TYPE_8U_C1, sl::MAT_TYPE_8U_C3 and sl::MAT_TYPE_8U_C4.  input files format are PNG and JPEG.  verbose sets, you have informations in case of failure. </dd></dl>

</div>
</div>
<a id="aeb25ebe04ae0193f13d34a77089b6b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb25ebe04ae0193f13d34a77089b6b04">&#9670;&nbsp;</a></span>setFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a> setFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsl_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___enumerations.html#ga6053bda451d8ca289b3e443377cfc004">COPY_TYPE</a>&#160;</td>
          <td class="paramname"><em>cpyType</em> = <code>COPY_TYPE_CPU_CPU</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from an other <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> (deep copy). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>: the <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> where the data will be copied from. </td></tr>
    <tr><td class="paramname">cpyType</td><td>: specify the memories that will be used for the update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sl::SUCCESS if everything went well, sl::ERROR_CODE_FAILURE otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the current <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> is not allocated or has a not a compatible sl::MAT_TYPE or <a class="el" href="structsl_1_1_resolution.html" title="Width and height of an array. ">sl::Resolution</a> with the source, current memory is freed and new memory is directly allocated. </dd></dl>

</div>
</div>
<a id="af000d3beacf03312363f52b1d8825ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af000d3beacf03312363f52b1d8825ccc">&#9670;&nbsp;</a></span>setTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a> setTo </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a>&#160;</td>
          <td class="paramname"><em>memory_type</em> = <code>MEM_CPU</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> with the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>: the value to be copied all over the matrix. </td></tr>
    <tr><td class="paramname">memory_type</td><td>: defines which buffer to fill, CPU and/or GPU. This function overwrite all the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is templated for sl::uchar1, sl::uchar2, sl::uchar3, sl::uchar4, sl::float1, sl::float2, sl::float3, sl::float4. </dd></dl>

</div>
</div>
<a id="a79fb42724066753c016b9b86145da01f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79fb42724066753c016b9b86145da01f">&#9670;&nbsp;</a></span>setValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a> setValue </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a>&#160;</td>
          <td class="paramname"><em>memory_type</em> = <code>MEM_CPU</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a value to a specific point in the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>: specify the column. </td></tr>
    <tr><td class="paramname">y</td><td>: specify the row. </td></tr>
    <tr><td class="paramname">value</td><td>: the value to be set. </td></tr>
    <tr><td class="paramname">memory_type</td><td>: defines which memory will be updated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sl::SUCCESS if everything went well, sl::ERROR_CODE_FAILURE otherwise. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not efficient for sl::MEM_GPU, use it on sparse data. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is templated for sl::uchar1, sl::uchar2, sl::uchar3, sl::uchar4, sl::float1, sl::float2, sl::float3, sl::float4. </dd></dl>

</div>
</div>
<a id="a61db709e04e1cd353b852514d280a99f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61db709e04e1cd353b852514d280a99f">&#9670;&nbsp;</a></span>updateCPUfromGPU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a> updateCPUfromGPU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Downloads data from DEVICE (GPU) to HOST (CPU), if possible. </p>
<dl class="section return"><dt>Returns</dt><dd>sl::SUCCESS if everything went well, sl::ERROR_CODE_FAILURE otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If no CPU or GPU memory are available for this <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a>, some are directly allocated. </dd>
<dd>
If verbose sets, you have informations in case of failure. </dd></dl>

</div>
</div>
<a id="afa6aadc30f3bc8df5e99850ff7e6cc4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa6aadc30f3bc8df5e99850ff7e6cc4b">&#9670;&nbsp;</a></span>updateGPUfromCPU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a> updateGPUfromCPU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uploads data from HOST (CPU) to DEVICE (GPU), if possible. </p>
<dl class="section return"><dt>Returns</dt><dd>sl::SUCCESS if everything went well, sl::ERROR_CODE_FAILURE otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If no CPU or GPU memory are available for this <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a>, some are directly allocated. </dd>
<dd>
If verbose sets, you have informations in case of failure. </dd></dl>

</div>
</div>
<a id="a7acf6247c440dcd777d3da7e55bee2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7acf6247c440dcd777d3da7e55bee2fd">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a> write </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the <a class="el" href="classsl_1_1_mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">sl::Mat</a> (only if sl::MEM_CPU is available) into a file as an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td>: file path including the name and extension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sl::SUCCESS if everything went well, sl::ERROR_CODE_FAILURE otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Supported sl::MAT_TYPE are : sl::MAT_TYPE_8U_C1, sl::MAT_TYPE_8U_C3 and sl::MAT_TYPE_8U_C4.  output files format are PNG and JPEG.  verbose sets, you have informations in case of failure. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>zed/sl/<a class="el" href="_core_8hpp_source.html">Core.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
