<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.11">
  <compounddef id="region__layer_8c" kind="file" language="C++">
    <compoundname>region_layer.c</compoundname>
    <includes refid="region__layer_8h" local="yes">region_layer.h</includes>
    <includes refid="activations_8h" local="yes">activations.h</includes>
    <includes refid="blas_8h" local="yes">blas.h</includes>
    <includes refid="box_8h" local="yes">box.h</includes>
    <includes refid="cuda_8h" local="yes">cuda.h</includes>
    <includes refid="utils_8h" local="yes">utils.h</includes>
    <includes local="no">stdio.h</includes>
    <includes local="no">assert.h</includes>
    <includes local="no">string.h</includes>
    <includes local="no">stdlib.h</includes>
    <incdepgraph>
      <node id="1527">
        <label>box.h</label>
        <link refid="box_8h_source"/>
        <childnode refid="1517" relation="include">
        </childnode>
      </node>
      <node id="1537">
        <label>assert.h</label>
      </node>
      <node id="1525">
        <label>float.h</label>
      </node>
      <node id="1518">
        <label>stdlib.h</label>
      </node>
      <node id="1533">
        <label>cuda.h</label>
        <link refid="cuda_8h_source"/>
        <childnode refid="1517" relation="include">
        </childnode>
      </node>
      <node id="1528">
        <label>data.h</label>
        <link refid="data_8h_source"/>
        <childnode refid="1521" relation="include">
        </childnode>
        <childnode refid="1517" relation="include">
        </childnode>
        <childnode refid="1529" relation="include">
        </childnode>
        <childnode refid="1530" relation="include">
        </childnode>
        <childnode refid="1524" relation="include">
        </childnode>
        <childnode refid="1531" relation="include">
        </childnode>
      </node>
      <node id="1523">
        <label>network.h</label>
        <link refid="network_8h_source"/>
        <childnode refid="1517" relation="include">
        </childnode>
        <childnode refid="1524" relation="include">
        </childnode>
        <childnode refid="1522" relation="include">
        </childnode>
        <childnode refid="1528" relation="include">
        </childnode>
        <childnode refid="1531" relation="include">
        </childnode>
      </node>
      <node id="1532">
        <label>activations.h</label>
        <link refid="activations_8h_source"/>
        <childnode refid="1517" relation="include">
        </childnode>
        <childnode refid="1533" relation="include">
        </childnode>
        <childnode refid="1526" relation="include">
        </childnode>
      </node>
      <node id="1530">
        <label>list.h</label>
        <link refid="list_8h_source"/>
        <childnode refid="1517" relation="include">
        </childnode>
      </node>
      <node id="1529">
        <label>matrix.h</label>
        <link refid="matrix_8h_source"/>
        <childnode refid="1517" relation="include">
        </childnode>
      </node>
      <node id="1517">
        <label>darknet.h</label>
        <link refid="darknet_8h_source"/>
        <childnode refid="1518" relation="include">
        </childnode>
        <childnode refid="1519" relation="include">
        </childnode>
        <childnode refid="1520" relation="include">
        </childnode>
        <childnode refid="1521" relation="include">
        </childnode>
      </node>
      <node id="1522">
        <label>layer.h</label>
        <link refid="layer_8h_source"/>
        <childnode refid="1517" relation="include">
        </childnode>
      </node>
      <node id="1521">
        <label>pthread.h</label>
      </node>
      <node id="1524">
        <label>image.h</label>
        <link refid="image_8h_source"/>
        <childnode refid="1518" relation="include">
        </childnode>
        <childnode refid="1519" relation="include">
        </childnode>
        <childnode refid="1525" relation="include">
        </childnode>
        <childnode refid="1520" relation="include">
        </childnode>
        <childnode refid="1526" relation="include">
        </childnode>
        <childnode refid="1527" relation="include">
        </childnode>
        <childnode refid="1517" relation="include">
        </childnode>
      </node>
      <node id="1520">
        <label>string.h</label>
      </node>
      <node id="1515">
        <label>/home/ubuntu/workspace/roboy_vision/src/pyyolo/darknet/src/region_layer.c</label>
        <link refid="region_layer.c"/>
        <childnode refid="1516" relation="include">
        </childnode>
        <childnode refid="1532" relation="include">
        </childnode>
        <childnode refid="1534" relation="include">
        </childnode>
        <childnode refid="1527" relation="include">
        </childnode>
        <childnode refid="1533" relation="include">
        </childnode>
        <childnode refid="1535" relation="include">
        </childnode>
        <childnode refid="1519" relation="include">
        </childnode>
        <childnode refid="1537" relation="include">
        </childnode>
        <childnode refid="1520" relation="include">
        </childnode>
        <childnode refid="1518" relation="include">
        </childnode>
      </node>
      <node id="1516">
        <label>region_layer.h</label>
        <link refid="region__layer_8h_source"/>
        <childnode refid="1517" relation="include">
        </childnode>
        <childnode refid="1522" relation="include">
        </childnode>
        <childnode refid="1523" relation="include">
        </childnode>
      </node>
      <node id="1534">
        <label>blas.h</label>
        <link refid="blas_8h_source"/>
        <childnode refid="1517" relation="include">
        </childnode>
      </node>
      <node id="1535">
        <label>utils.h</label>
        <link refid="utils_8h_source"/>
        <childnode refid="1519" relation="include">
        </childnode>
        <childnode refid="1536" relation="include">
        </childnode>
        <childnode refid="1517" relation="include">
        </childnode>
        <childnode refid="1530" relation="include">
        </childnode>
      </node>
      <node id="1536">
        <label>time.h</label>
      </node>
      <node id="1526">
        <label>math.h</label>
      </node>
      <node id="1531">
        <label>tree.h</label>
        <link refid="tree_8h_source"/>
        <childnode refid="1517" relation="include">
        </childnode>
      </node>
      <node id="1519">
        <label>stdio.h</label>
      </node>
    </incdepgraph>
      <sectiondef kind="func">
      <memberdef kind="function" id="region__layer_8c_1adf8270bd92c2f250a4ceab2b98e37d37" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structlayer" kindref="compound">layer</ref></type>
        <definition>layer make_region_layer</definition>
        <argsstring>(int batch, int w, int h, int n, int classes, int coords)</argsstring>
        <name>make_region_layer</name>
        <param>
          <type>int</type>
          <declname>batch</declname>
        </param>
        <param>
          <type>int</type>
          <declname>w</declname>
        </param>
        <param>
          <type>int</type>
          <declname>h</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <param>
          <type>int</type>
          <declname>classes</declname>
        </param>
        <param>
          <type>int</type>
          <declname>coords</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/ubuntu/workspace/roboy_vision/src/pyyolo/darknet/src/region_layer.c" line="13" column="1" bodyfile="/home/ubuntu/workspace/roboy_vision/src/pyyolo/darknet/src/region_layer.c" bodystart="13" bodyend="54"/>
      </memberdef>
      <memberdef kind="function" id="region__layer_8c_1a882147a796b341f5ec5989f0e71b7797" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void resize_region_layer</definition>
        <argsstring>(layer *l, int w, int h)</argsstring>
        <name>resize_region_layer</name>
        <param>
          <type><ref refid="structlayer" kindref="compound">layer</ref> *</type>
          <declname>l</declname>
        </param>
        <param>
          <type>int</type>
          <declname>w</declname>
        </param>
        <param>
          <type>int</type>
          <declname>h</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/ubuntu/workspace/roboy_vision/src/pyyolo/darknet/src/region_layer.c" line="56" column="1" bodyfile="/home/ubuntu/workspace/roboy_vision/src/pyyolo/darknet/src/region_layer.c" bodystart="56" bodyend="74"/>
      </memberdef>
      <memberdef kind="function" id="region__layer_8c_1aca90641426af39fb8ed8f9f4ea292e92" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structbox" kindref="compound">box</ref></type>
        <definition>box get_region_box</definition>
        <argsstring>(float *x, float *biases, int n, int index, int i, int j, int w, int h, int stride)</argsstring>
        <name>get_region_box</name>
        <param>
          <type>float *</type>
          <declname>x</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>biases</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <param>
          <type>int</type>
          <declname>index</declname>
        </param>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <param>
          <type>int</type>
          <declname>j</declname>
        </param>
        <param>
          <type>int</type>
          <declname>w</declname>
        </param>
        <param>
          <type>int</type>
          <declname>h</declname>
        </param>
        <param>
          <type>int</type>
          <declname>stride</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/ubuntu/workspace/roboy_vision/src/pyyolo/darknet/src/region_layer.c" line="76" column="1" bodyfile="/home/ubuntu/workspace/roboy_vision/src/pyyolo/darknet/src/region_layer.c" bodystart="76" bodyend="84"/>
      </memberdef>
      <memberdef kind="function" id="region__layer_8c_1a745171a1090e6f08bd824fb47b764216" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>float</type>
        <definition>float delta_region_box</definition>
        <argsstring>(box truth, float *x, float *biases, int n, int index, int i, int j, int w, int h, float *delta, float scale, int stride)</argsstring>
        <name>delta_region_box</name>
        <param>
          <type><ref refid="structbox" kindref="compound">box</ref></type>
          <declname>truth</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>x</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>biases</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <param>
          <type>int</type>
          <declname>index</declname>
        </param>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <param>
          <type>int</type>
          <declname>j</declname>
        </param>
        <param>
          <type>int</type>
          <declname>w</declname>
        </param>
        <param>
          <type>int</type>
          <declname>h</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>delta</declname>
        </param>
        <param>
          <type>float</type>
          <declname>scale</declname>
        </param>
        <param>
          <type>int</type>
          <declname>stride</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/ubuntu/workspace/roboy_vision/src/pyyolo/darknet/src/region_layer.c" line="86" column="1" bodyfile="/home/ubuntu/workspace/roboy_vision/src/pyyolo/darknet/src/region_layer.c" bodystart="86" bodyend="101"/>
      </memberdef>
      <memberdef kind="function" id="region__layer_8c_1ae00d9281847c8b13313f8f0c863a9418" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void delta_region_mask</definition>
        <argsstring>(float *truth, float *x, int n, int index, float *delta, int stride, int scale)</argsstring>
        <name>delta_region_mask</name>
        <param>
          <type>float *</type>
          <declname>truth</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>x</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <param>
          <type>int</type>
          <declname>index</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>delta</declname>
        </param>
        <param>
          <type>int</type>
          <declname>stride</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scale</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/ubuntu/workspace/roboy_vision/src/pyyolo/darknet/src/region_layer.c" line="103" column="1" bodyfile="/home/ubuntu/workspace/roboy_vision/src/pyyolo/darknet/src/region_layer.c" bodystart="103" bodyend="109"/>
      </memberdef>
      <memberdef kind="function" id="region__layer_8c_1aa771812f7eca72867188ba440d6d00ac" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void delta_region_class</definition>
        <argsstring>(float *output, float *delta, int index, int class, int classes, tree *hier, float scale, int stride, float *avg_cat)</argsstring>
        <name>delta_region_class</name>
        <param>
          <type>float *</type>
          <declname>output</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>delta</declname>
        </param>
        <param>
          <type>int</type>
          <declname>index</declname>
        </param>
        <param>
          <type>int</type>
          <declname>class</declname>
        </param>
        <param>
          <type>int</type>
          <declname>classes</declname>
        </param>
        <param>
          <type><ref refid="structtree" kindref="compound">tree</ref> *</type>
          <declname>hier</declname>
        </param>
        <param>
          <type>float</type>
          <declname>scale</declname>
        </param>
        <param>
          <type>int</type>
          <declname>stride</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>avg_cat</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/ubuntu/workspace/roboy_vision/src/pyyolo/darknet/src/region_layer.c" line="112" column="1" bodyfile="/home/ubuntu/workspace/roboy_vision/src/pyyolo/darknet/src/region_layer.c" bodystart="112" bodyend="135"/>
      </memberdef>
      <memberdef kind="function" id="region__layer_8c_1ae78a64fa28eedd9d67db987b4e6cdbab" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>float</type>
        <definition>float logit</definition>
        <argsstring>(float x)</argsstring>
        <name>logit</name>
        <param>
          <type>float</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/ubuntu/workspace/roboy_vision/src/pyyolo/darknet/src/region_layer.c" line="137" column="1" bodyfile="/home/ubuntu/workspace/roboy_vision/src/pyyolo/darknet/src/region_layer.c" bodystart="137" bodyend="140"/>
      </memberdef>
      <memberdef kind="function" id="region__layer_8c_1a81568d0ffbba5b9640b433ffb03105a6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>float</type>
        <definition>float tisnan</definition>
        <argsstring>(float x)</argsstring>
        <name>tisnan</name>
        <param>
          <type>float</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/ubuntu/workspace/roboy_vision/src/pyyolo/darknet/src/region_layer.c" line="142" column="1" bodyfile="/home/ubuntu/workspace/roboy_vision/src/pyyolo/darknet/src/region_layer.c" bodystart="142" bodyend="145"/>
      </memberdef>
      <memberdef kind="function" id="region__layer_8c_1ac3c785a8f7fdc0d10f1c4330bee08b48" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int entry_index</definition>
        <argsstring>(layer l, int batch, int location, int entry)</argsstring>
        <name>entry_index</name>
        <param>
          <type><ref refid="structlayer" kindref="compound">layer</ref></type>
          <declname>l</declname>
        </param>
        <param>
          <type>int</type>
          <declname>batch</declname>
        </param>
        <param>
          <type>int</type>
          <declname>location</declname>
        </param>
        <param>
          <type>int</type>
          <declname>entry</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/ubuntu/workspace/roboy_vision/src/pyyolo/darknet/src/region_layer.c" line="147" column="1" bodyfile="/home/ubuntu/workspace/roboy_vision/src/pyyolo/darknet/src/region_layer.c" bodystart="147" bodyend="152"/>
      </memberdef>
      <memberdef kind="function" id="region__layer_8c_1a7df2017786a6b8cc6dc6a15d5024d6b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void forward_region_layer</definition>
        <argsstring>(const layer l, network net)</argsstring>
        <name>forward_region_layer</name>
        <param>
          <type>const <ref refid="structlayer" kindref="compound">layer</ref></type>
          <declname>l</declname>
        </param>
        <param>
          <type><ref refid="structnetwork" kindref="compound">network</ref></type>
          <declname>net</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/ubuntu/workspace/roboy_vision/src/pyyolo/darknet/src/region_layer.c" line="154" column="1" bodyfile="/home/ubuntu/workspace/roboy_vision/src/pyyolo/darknet/src/region_layer.c" bodystart="154" bodyend="321"/>
      </memberdef>
      <memberdef kind="function" id="region__layer_8c_1a1823033f070004078252d6c00eb27039" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void backward_region_layer</definition>
        <argsstring>(const layer l, network net)</argsstring>
        <name>backward_region_layer</name>
        <param>
          <type>const <ref refid="structlayer" kindref="compound">layer</ref></type>
          <declname>l</declname>
        </param>
        <param>
          <type><ref refid="structnetwork" kindref="compound">network</ref></type>
          <declname>net</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/ubuntu/workspace/roboy_vision/src/pyyolo/darknet/src/region_layer.c" line="323" column="1" bodyfile="/home/ubuntu/workspace/roboy_vision/src/pyyolo/darknet/src/region_layer.c" bodystart="323" bodyend="334"/>
      </memberdef>
      <memberdef kind="function" id="region__layer_8c_1acb8eecea72f5b9f73b785baa78b6f107" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void correct_region_boxes</definition>
        <argsstring>(box *boxes, int n, int w, int h, int netw, int neth, int relative)</argsstring>
        <name>correct_region_boxes</name>
        <param>
          <type><ref refid="structbox" kindref="compound">box</ref> *</type>
          <declname>boxes</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <param>
          <type>int</type>
          <declname>w</declname>
        </param>
        <param>
          <type>int</type>
          <declname>h</declname>
        </param>
        <param>
          <type>int</type>
          <declname>netw</declname>
        </param>
        <param>
          <type>int</type>
          <declname>neth</declname>
        </param>
        <param>
          <type>int</type>
          <declname>relative</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/ubuntu/workspace/roboy_vision/src/pyyolo/darknet/src/region_layer.c" line="336" column="1" bodyfile="/home/ubuntu/workspace/roboy_vision/src/pyyolo/darknet/src/region_layer.c" bodystart="336" bodyend="362"/>
      </memberdef>
      <memberdef kind="function" id="region__layer_8c_1ac96eb3a67f501dde1b28dc7434ade82a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void get_region_boxes</definition>
        <argsstring>(layer l, int w, int h, int netw, int neth, float thresh, float **probs, box *boxes, float **masks, int only_objectness, int *map, float tree_thresh, int relative)</argsstring>
        <name>get_region_boxes</name>
        <param>
          <type><ref refid="structlayer" kindref="compound">layer</ref></type>
          <declname>l</declname>
        </param>
        <param>
          <type>int</type>
          <declname>w</declname>
        </param>
        <param>
          <type>int</type>
          <declname>h</declname>
        </param>
        <param>
          <type>int</type>
          <declname>netw</declname>
        </param>
        <param>
          <type>int</type>
          <declname>neth</declname>
        </param>
        <param>
          <type>float</type>
          <declname>thresh</declname>
        </param>
        <param>
          <type>float **</type>
          <declname>probs</declname>
        </param>
        <param>
          <type><ref refid="structbox" kindref="compound">box</ref> *</type>
          <declname>boxes</declname>
        </param>
        <param>
          <type>float **</type>
          <declname>masks</declname>
        </param>
        <param>
          <type>int</type>
          <declname>only_objectness</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>map</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tree_thresh</declname>
        </param>
        <param>
          <type>int</type>
          <declname>relative</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/ubuntu/workspace/roboy_vision/src/pyyolo/darknet/src/region_layer.c" line="364" column="1" bodyfile="/home/ubuntu/workspace/roboy_vision/src/pyyolo/darknet/src/region_layer.c" bodystart="364" bodyend="451"/>
      </memberdef>
      <memberdef kind="function" id="region__layer_8c_1a482d1347c52a7651d858f842518c705e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void zero_objectness</definition>
        <argsstring>(layer l)</argsstring>
        <name>zero_objectness</name>
        <param>
          <type><ref refid="structlayer" kindref="compound">layer</ref></type>
          <declname>l</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/ubuntu/workspace/roboy_vision/src/pyyolo/darknet/src/region_layer.c" line="581" column="1" bodyfile="/home/ubuntu/workspace/roboy_vision/src/pyyolo/darknet/src/region_layer.c" bodystart="581" bodyend="590"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="preprocessor">#include<sp/>&quot;region_layer.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;activations.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;blas.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;box.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;cuda.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;utils.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7"><highlight class="normal"></highlight></codeline>
<codeline lineno="8"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdio.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;assert.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;string.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdlib.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12"><highlight class="normal"></highlight></codeline>
<codeline lineno="13"><highlight class="normal"><ref refid="structlayer" kindref="compound">layer</ref><sp/>make_region_layer(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>batch,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>w,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>h,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>classes,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>coords)</highlight></codeline>
<codeline lineno="14"><highlight class="normal">{</highlight></codeline>
<codeline lineno="15"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structlayer" kindref="compound">layer</ref><sp/>l<sp/>=<sp/>{0};</highlight></codeline>
<codeline lineno="16"><highlight class="normal"><sp/><sp/><sp/><sp/>l.type<sp/>=<sp/>REGION;</highlight></codeline>
<codeline lineno="17"><highlight class="normal"></highlight></codeline>
<codeline lineno="18"><highlight class="normal"><sp/><sp/><sp/><sp/>l.n<sp/>=<sp/>n;</highlight></codeline>
<codeline lineno="19"><highlight class="normal"><sp/><sp/><sp/><sp/>l.batch<sp/>=<sp/>batch;</highlight></codeline>
<codeline lineno="20"><highlight class="normal"><sp/><sp/><sp/><sp/>l.h<sp/>=<sp/>h;</highlight></codeline>
<codeline lineno="21"><highlight class="normal"><sp/><sp/><sp/><sp/>l.w<sp/>=<sp/>w;</highlight></codeline>
<codeline lineno="22"><highlight class="normal"><sp/><sp/><sp/><sp/>l.c<sp/>=<sp/>n*(classes<sp/>+<sp/>coords<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="23"><highlight class="normal"><sp/><sp/><sp/><sp/>l.out_w<sp/>=<sp/>l.w;</highlight></codeline>
<codeline lineno="24"><highlight class="normal"><sp/><sp/><sp/><sp/>l.out_h<sp/>=<sp/>l.h;</highlight></codeline>
<codeline lineno="25"><highlight class="normal"><sp/><sp/><sp/><sp/>l.out_c<sp/>=<sp/>l.c;</highlight></codeline>
<codeline lineno="26"><highlight class="normal"><sp/><sp/><sp/><sp/>l.classes<sp/>=<sp/>classes;</highlight></codeline>
<codeline lineno="27"><highlight class="normal"><sp/><sp/><sp/><sp/>l.coords<sp/>=<sp/>coords;</highlight></codeline>
<codeline lineno="28"><highlight class="normal"><sp/><sp/><sp/><sp/>l.cost<sp/>=<sp/>calloc(1,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="29"><highlight class="normal"><sp/><sp/><sp/><sp/>l.biases<sp/>=<sp/>calloc(n*2,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="30"><highlight class="normal"><sp/><sp/><sp/><sp/>l.bias_updates<sp/>=<sp/>calloc(n*2,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="31"><highlight class="normal"><sp/><sp/><sp/><sp/>l.outputs<sp/>=<sp/>h*w*n*(classes<sp/>+<sp/>coords<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="32"><highlight class="normal"><sp/><sp/><sp/><sp/>l.inputs<sp/>=<sp/>l.outputs;</highlight></codeline>
<codeline lineno="33"><highlight class="normal"><sp/><sp/><sp/><sp/>l.truths<sp/>=<sp/>30*(l.coords<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="34"><highlight class="normal"><sp/><sp/><sp/><sp/>l.delta<sp/>=<sp/>calloc(batch*l.outputs,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="35"><highlight class="normal"><sp/><sp/><sp/><sp/>l.output<sp/>=<sp/>calloc(batch*l.outputs,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="36"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i;</highlight></codeline>
<codeline lineno="37"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>n*2;<sp/>++i){</highlight></codeline>
<codeline lineno="38"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>l.biases[i]<sp/>=<sp/>.5;</highlight></codeline>
<codeline lineno="39"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="40"><highlight class="normal"></highlight></codeline>
<codeline lineno="41"><highlight class="normal"><sp/><sp/><sp/><sp/>l.forward<sp/>=<sp/>forward_region_layer;</highlight></codeline>
<codeline lineno="42"><highlight class="normal"><sp/><sp/><sp/><sp/>l.backward<sp/>=<sp/>backward_region_layer;</highlight></codeline>
<codeline lineno="43"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>GPU</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="44"><highlight class="normal"><sp/><sp/><sp/><sp/>l.forward_gpu<sp/>=<sp/>forward_region_layer_gpu;</highlight></codeline>
<codeline lineno="45"><highlight class="normal"><sp/><sp/><sp/><sp/>l.backward_gpu<sp/>=<sp/>backward_region_layer_gpu;</highlight></codeline>
<codeline lineno="46"><highlight class="normal"><sp/><sp/><sp/><sp/>l.output_gpu<sp/>=<sp/>cuda_make_array(l.output,<sp/>batch*l.outputs);</highlight></codeline>
<codeline lineno="47"><highlight class="normal"><sp/><sp/><sp/><sp/>l.delta_gpu<sp/>=<sp/>cuda_make_array(l.delta,<sp/>batch*l.outputs);</highlight></codeline>
<codeline lineno="48"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="49"><highlight class="normal"></highlight></codeline>
<codeline lineno="50"><highlight class="normal"><sp/><sp/><sp/><sp/>fprintf(stderr,<sp/></highlight><highlight class="stringliteral">&quot;detection\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="51"><highlight class="normal"><sp/><sp/><sp/><sp/>srand(0);</highlight></codeline>
<codeline lineno="52"><highlight class="normal"></highlight></codeline>
<codeline lineno="53"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>l;</highlight></codeline>
<codeline lineno="54"><highlight class="normal">}</highlight></codeline>
<codeline lineno="55"><highlight class="normal"></highlight></codeline>
<codeline lineno="56"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>resize_region_layer(<ref refid="structlayer" kindref="compound">layer</ref><sp/>*l,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>w,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>h)</highlight></codeline>
<codeline lineno="57"><highlight class="normal">{</highlight></codeline>
<codeline lineno="58"><highlight class="normal"><sp/><sp/><sp/><sp/>l-&gt;w<sp/>=<sp/>w;</highlight></codeline>
<codeline lineno="59"><highlight class="normal"><sp/><sp/><sp/><sp/>l-&gt;h<sp/>=<sp/>h;</highlight></codeline>
<codeline lineno="60"><highlight class="normal"></highlight></codeline>
<codeline lineno="61"><highlight class="normal"><sp/><sp/><sp/><sp/>l-&gt;outputs<sp/>=<sp/>h*w*l-&gt;n*(l-&gt;classes<sp/>+<sp/>l-&gt;coords<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="62"><highlight class="normal"><sp/><sp/><sp/><sp/>l-&gt;inputs<sp/>=<sp/>l-&gt;outputs;</highlight></codeline>
<codeline lineno="63"><highlight class="normal"></highlight></codeline>
<codeline lineno="64"><highlight class="normal"><sp/><sp/><sp/><sp/>l-&gt;output<sp/>=<sp/>realloc(l-&gt;output,<sp/>l-&gt;batch*l-&gt;outputs*</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="65"><highlight class="normal"><sp/><sp/><sp/><sp/>l-&gt;delta<sp/>=<sp/>realloc(l-&gt;delta,<sp/>l-&gt;batch*l-&gt;outputs*</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="66"><highlight class="normal"></highlight></codeline>
<codeline lineno="67"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>GPU</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="68"><highlight class="normal"><sp/><sp/><sp/><sp/>cuda_free(l-&gt;delta_gpu);</highlight></codeline>
<codeline lineno="69"><highlight class="normal"><sp/><sp/><sp/><sp/>cuda_free(l-&gt;output_gpu);</highlight></codeline>
<codeline lineno="70"><highlight class="normal"></highlight></codeline>
<codeline lineno="71"><highlight class="normal"><sp/><sp/><sp/><sp/>l-&gt;delta_gpu<sp/>=<sp/><sp/><sp/><sp/><sp/>cuda_make_array(l-&gt;delta,<sp/>l-&gt;batch*l-&gt;outputs);</highlight></codeline>
<codeline lineno="72"><highlight class="normal"><sp/><sp/><sp/><sp/>l-&gt;output_gpu<sp/>=<sp/><sp/><sp/><sp/>cuda_make_array(l-&gt;output,<sp/>l-&gt;batch*l-&gt;outputs);</highlight></codeline>
<codeline lineno="73"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="74"><highlight class="normal">}</highlight></codeline>
<codeline lineno="75"><highlight class="normal"></highlight></codeline>
<codeline lineno="76"><highlight class="normal"><ref refid="structbox" kindref="compound">box</ref><sp/>get_region_box(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*x,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*biases,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>index,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>w,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>h,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>stride)</highlight></codeline>
<codeline lineno="77"><highlight class="normal">{</highlight></codeline>
<codeline lineno="78"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structbox" kindref="compound">box</ref><sp/>b;</highlight></codeline>
<codeline lineno="79"><highlight class="normal"><sp/><sp/><sp/><sp/>b.x<sp/>=<sp/>(i<sp/>+<sp/>x[index<sp/>+<sp/>0*stride])<sp/>/<sp/>w;</highlight></codeline>
<codeline lineno="80"><highlight class="normal"><sp/><sp/><sp/><sp/>b.y<sp/>=<sp/>(j<sp/>+<sp/>x[index<sp/>+<sp/>1*stride])<sp/>/<sp/>h;</highlight></codeline>
<codeline lineno="81"><highlight class="normal"><sp/><sp/><sp/><sp/>b.w<sp/>=<sp/>exp(x[index<sp/>+<sp/>2*stride])<sp/>*<sp/>biases[2*n]<sp/><sp/><sp/>/<sp/>w;</highlight></codeline>
<codeline lineno="82"><highlight class="normal"><sp/><sp/><sp/><sp/>b.h<sp/>=<sp/>exp(x[index<sp/>+<sp/>3*stride])<sp/>*<sp/>biases[2*n+1]<sp/>/<sp/>h;</highlight></codeline>
<codeline lineno="83"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>b;</highlight></codeline>
<codeline lineno="84"><highlight class="normal">}</highlight></codeline>
<codeline lineno="85"><highlight class="normal"></highlight></codeline>
<codeline lineno="86"><highlight class="normal"></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>delta_region_box(<ref refid="structbox" kindref="compound">box</ref><sp/>truth,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*x,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*biases,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>index,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>w,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>h,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*delta,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>scale,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>stride)</highlight></codeline>
<codeline lineno="87"><highlight class="normal">{</highlight></codeline>
<codeline lineno="88"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structbox" kindref="compound">box</ref><sp/>pred<sp/>=<sp/>get_region_box(x,<sp/>biases,<sp/>n,<sp/>index,<sp/>i,<sp/>j,<sp/>w,<sp/>h,<sp/>stride);</highlight></codeline>
<codeline lineno="89"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>iou<sp/>=<sp/>box_iou(pred,<sp/>truth);</highlight></codeline>
<codeline lineno="90"><highlight class="normal"></highlight></codeline>
<codeline lineno="91"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>tx<sp/>=<sp/>(truth.x*w<sp/>-<sp/>i);</highlight></codeline>
<codeline lineno="92"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>ty<sp/>=<sp/>(truth.y*h<sp/>-<sp/>j);</highlight></codeline>
<codeline lineno="93"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>tw<sp/>=<sp/>log(truth.w*w<sp/>/<sp/>biases[2*n]);</highlight></codeline>
<codeline lineno="94"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>th<sp/>=<sp/>log(truth.h*h<sp/>/<sp/>biases[2*n<sp/>+<sp/>1]);</highlight></codeline>
<codeline lineno="95"><highlight class="normal"></highlight></codeline>
<codeline lineno="96"><highlight class="normal"><sp/><sp/><sp/><sp/>delta[index<sp/>+<sp/>0*stride]<sp/>=<sp/>scale<sp/>*<sp/>(tx<sp/>-<sp/>x[index<sp/>+<sp/>0*stride]);</highlight></codeline>
<codeline lineno="97"><highlight class="normal"><sp/><sp/><sp/><sp/>delta[index<sp/>+<sp/>1*stride]<sp/>=<sp/>scale<sp/>*<sp/>(ty<sp/>-<sp/>x[index<sp/>+<sp/>1*stride]);</highlight></codeline>
<codeline lineno="98"><highlight class="normal"><sp/><sp/><sp/><sp/>delta[index<sp/>+<sp/>2*stride]<sp/>=<sp/>scale<sp/>*<sp/>(tw<sp/>-<sp/>x[index<sp/>+<sp/>2*stride]);</highlight></codeline>
<codeline lineno="99"><highlight class="normal"><sp/><sp/><sp/><sp/>delta[index<sp/>+<sp/>3*stride]<sp/>=<sp/>scale<sp/>*<sp/>(th<sp/>-<sp/>x[index<sp/>+<sp/>3*stride]);</highlight></codeline>
<codeline lineno="100"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>iou;</highlight></codeline>
<codeline lineno="101"><highlight class="normal">}</highlight></codeline>
<codeline lineno="102"><highlight class="normal"></highlight></codeline>
<codeline lineno="103"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>delta_region_mask(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*truth,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*x,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>index,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*delta,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>stride,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>scale)</highlight></codeline>
<codeline lineno="104"><highlight class="normal">{</highlight></codeline>
<codeline lineno="105"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i;</highlight></codeline>
<codeline lineno="106"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>n;<sp/>++i){</highlight></codeline>
<codeline lineno="107"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>delta[index<sp/>+<sp/>i*stride]<sp/>=<sp/>scale*(truth[i]<sp/>-<sp/>x[index<sp/>+<sp/>i*stride]);</highlight></codeline>
<codeline lineno="108"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="109"><highlight class="normal">}</highlight></codeline>
<codeline lineno="110"><highlight class="normal"></highlight></codeline>
<codeline lineno="111"><highlight class="normal"></highlight></codeline>
<codeline lineno="112"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>delta_region_class(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*output,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*delta,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>index,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal">,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>classes,<sp/><ref refid="structtree" kindref="compound">tree</ref><sp/>*hier,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>scale,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>stride,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*avg_cat)</highlight></codeline>
<codeline lineno="113"><highlight class="normal">{</highlight></codeline>
<codeline lineno="114"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/>n;</highlight></codeline>
<codeline lineno="115"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(hier){</highlight></codeline>
<codeline lineno="116"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>pred<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="117"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal">(</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>&gt;=<sp/>0){</highlight></codeline>
<codeline lineno="118"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pred<sp/>*=<sp/>output[index<sp/>+<sp/>stride*</highlight><highlight class="keyword">class</highlight><highlight class="normal">];</highlight></codeline>
<codeline lineno="119"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>g<sp/>=<sp/>hier-&gt;group[</highlight><highlight class="keyword">class</highlight><highlight class="normal">];</highlight></codeline>
<codeline lineno="120"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>offset<sp/>=<sp/>hier-&gt;group_offset[g];</highlight></codeline>
<codeline lineno="121"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>hier-&gt;group_size[g];<sp/>++i){</highlight></codeline>
<codeline lineno="122"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>delta[index<sp/>+<sp/>stride*(offset<sp/>+<sp/>i)]<sp/>=<sp/>scale<sp/>*<sp/>(0<sp/>-<sp/>output[index<sp/>+<sp/>stride*(offset<sp/>+<sp/>i)]);</highlight></codeline>
<codeline lineno="123"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="124"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>delta[index<sp/>+<sp/>stride*</highlight><highlight class="keyword">class</highlight><highlight class="normal">]<sp/>=<sp/>scale<sp/>*<sp/>(1<sp/>-<sp/>output[index<sp/>+<sp/>stride*</highlight><highlight class="keyword">class</highlight><highlight class="normal">]);</highlight></codeline>
<codeline lineno="125"><highlight class="normal"></highlight></codeline>
<codeline lineno="126"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">=<sp/>hier-&gt;parent[class];</highlight></codeline>
<codeline lineno="127"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="128"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*avg_cat<sp/>+=<sp/>pred;</highlight></codeline>
<codeline lineno="129"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="130"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(n<sp/>=<sp/>0;<sp/>n<sp/>&lt;<sp/>classes;<sp/>++n){</highlight></codeline>
<codeline lineno="131"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>delta[index<sp/>+<sp/>stride*n]<sp/>=<sp/>scale<sp/>*<sp/>(((n<sp/>==<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal">)?1<sp/>:<sp/>0)<sp/>-<sp/>output[index<sp/>+<sp/>stride*n]);</highlight></codeline>
<codeline lineno="132"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(n<sp/>==<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal">)<sp/>*avg_cat<sp/>+=<sp/>output[index<sp/>+<sp/>stride*n];</highlight></codeline>
<codeline lineno="133"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="134"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="135"><highlight class="normal">}</highlight></codeline>
<codeline lineno="136"><highlight class="normal"></highlight></codeline>
<codeline lineno="137"><highlight class="normal"></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>logit(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>x)</highlight></codeline>
<codeline lineno="138"><highlight class="normal">{</highlight></codeline>
<codeline lineno="139"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>log(x/(1.-x));</highlight></codeline>
<codeline lineno="140"><highlight class="normal">}</highlight></codeline>
<codeline lineno="141"><highlight class="normal"></highlight></codeline>
<codeline lineno="142"><highlight class="normal"></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>tisnan(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>x)</highlight></codeline>
<codeline lineno="143"><highlight class="normal">{</highlight></codeline>
<codeline lineno="144"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(x<sp/>!=<sp/>x);</highlight></codeline>
<codeline lineno="145"><highlight class="normal">}</highlight></codeline>
<codeline lineno="146"><highlight class="normal"></highlight></codeline>
<codeline lineno="147"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>entry_index(<ref refid="structlayer" kindref="compound">layer</ref><sp/>l,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>batch,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>location,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>entry)</highlight></codeline>
<codeline lineno="148"><highlight class="normal">{</highlight></codeline>
<codeline lineno="149"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n<sp/>=<sp/><sp/><sp/>location<sp/>/<sp/>(l.w*l.h);</highlight></codeline>
<codeline lineno="150"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>loc<sp/>=<sp/>location<sp/>%<sp/>(l.w*l.h);</highlight></codeline>
<codeline lineno="151"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>batch*l.outputs<sp/>+<sp/>n*l.w*l.h*(l.coords+l.classes+1)<sp/>+<sp/>entry*l.w*l.h<sp/>+<sp/>loc;</highlight></codeline>
<codeline lineno="152"><highlight class="normal">}</highlight></codeline>
<codeline lineno="153"><highlight class="normal"></highlight></codeline>
<codeline lineno="154"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>forward_region_layer(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structlayer" kindref="compound">layer</ref><sp/>l,<sp/><ref refid="structnetwork" kindref="compound">network</ref><sp/>net)</highlight></codeline>
<codeline lineno="155"><highlight class="normal">{</highlight></codeline>
<codeline lineno="156"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,j,b,t,n;</highlight></codeline>
<codeline lineno="157"><highlight class="normal"><sp/><sp/><sp/><sp/>memcpy(l.output,<sp/>net.input,<sp/>l.outputs*l.batch*</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="158"><highlight class="normal"></highlight></codeline>
<codeline lineno="159"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>GPU</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="160"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(b<sp/>=<sp/>0;<sp/>b<sp/>&lt;<sp/>l.batch;<sp/>++b){</highlight></codeline>
<codeline lineno="161"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(n<sp/>=<sp/>0;<sp/>n<sp/>&lt;<sp/>l.n;<sp/>++n){</highlight></codeline>
<codeline lineno="162"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>index<sp/>=<sp/>entry_index(l,<sp/>b,<sp/>n*l.w*l.h,<sp/>0);</highlight></codeline>
<codeline lineno="163"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>activate_array(l.output<sp/>+<sp/>index,<sp/>2*l.w*l.h,<sp/>LOGISTIC);</highlight></codeline>
<codeline lineno="164"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>index<sp/>=<sp/>entry_index(l,<sp/>b,<sp/>n*l.w*l.h,<sp/>l.coords);</highlight></codeline>
<codeline lineno="165"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!l.background)<sp/>activate_array(l.output<sp/>+<sp/>index,<sp/><sp/><sp/>l.w*l.h,<sp/>LOGISTIC);</highlight></codeline>
<codeline lineno="166"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="167"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="168"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(l.softmax_tree){</highlight></codeline>
<codeline lineno="169"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i;</highlight></codeline>
<codeline lineno="170"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>count<sp/>=<sp/>l.coords<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="171"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>l.softmax_tree-&gt;groups;<sp/>++i)<sp/>{</highlight></codeline>
<codeline lineno="172"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>group_size<sp/>=<sp/>l.softmax_tree-&gt;group_size[i];</highlight></codeline>
<codeline lineno="173"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>softmax_cpu(net.input<sp/>+<sp/>count,<sp/>group_size,<sp/>l.batch,<sp/>l.inputs,<sp/>l.n*l.w*l.h,<sp/>1,<sp/>l.n*l.w*l.h,<sp/>l.temperature,<sp/>l.output<sp/>+<sp/>count);</highlight></codeline>
<codeline lineno="174"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>count<sp/>+=<sp/>group_size;</highlight></codeline>
<codeline lineno="175"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="176"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(l.softmax){</highlight></codeline>
<codeline lineno="177"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>index<sp/>=<sp/>entry_index(l,<sp/>0,<sp/>0,<sp/>l.coords<sp/>+<sp/>!l.background);</highlight></codeline>
<codeline lineno="178"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>softmax_cpu(net.input<sp/>+<sp/>index,<sp/>l.classes<sp/>+<sp/>l.background,<sp/>l.batch*l.n,<sp/>l.inputs/l.n,<sp/>l.w*l.h,<sp/>1,<sp/>l.w*l.h,<sp/>1,<sp/>l.output<sp/>+<sp/>index);</highlight></codeline>
<codeline lineno="179"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="180"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="181"><highlight class="normal"></highlight></codeline>
<codeline lineno="182"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(l.delta,<sp/>0,<sp/>l.outputs<sp/>*<sp/>l.batch<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="183"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!net.train)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="184"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>avg_iou<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="185"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>recall<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="186"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>avg_cat<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="187"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>avg_obj<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="188"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>avg_anyobj<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="189"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>count<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="190"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>class_count<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="191"><highlight class="normal"><sp/><sp/><sp/><sp/>*(l.cost)<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="192"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(b<sp/>=<sp/>0;<sp/>b<sp/>&lt;<sp/>l.batch;<sp/>++b)<sp/>{</highlight></codeline>
<codeline lineno="193"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(l.softmax_tree){</highlight></codeline>
<codeline lineno="194"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>onlyclass<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="195"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(t<sp/>=<sp/>0;<sp/>t<sp/>&lt;<sp/>30;<sp/>++t){</highlight></codeline>
<codeline lineno="196"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structbox" kindref="compound">box</ref><sp/>truth<sp/>=<sp/>float_to_box(net.truth<sp/>+<sp/>t*(l.coords<sp/>+<sp/>1)<sp/>+<sp/>b*l.truths,<sp/>1);</highlight></codeline>
<codeline lineno="197"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!truth.x)<sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="198"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">=<sp/>net.truth[t*(l.coords<sp/>+<sp/>1)<sp/>+<sp/>b*l.truths<sp/>+<sp/>l.coords];</highlight></codeline>
<codeline lineno="199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>maxp<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="200"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>maxi<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="201"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(truth.x<sp/>&gt;<sp/>100000<sp/>&amp;&amp;<sp/>truth.y<sp/>&gt;<sp/>100000){</highlight></codeline>
<codeline lineno="202"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(n<sp/>=<sp/>0;<sp/>n<sp/>&lt;<sp/>l.n*l.w*l.h;<sp/>++n){</highlight></codeline>
<codeline lineno="203"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>class_index<sp/>=<sp/>entry_index(l,<sp/>b,<sp/>n,<sp/>l.coords<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="204"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>obj_index<sp/>=<sp/>entry_index(l,<sp/>b,<sp/>n,<sp/>l.coords);</highlight></codeline>
<codeline lineno="205"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>scale<sp/>=<sp/><sp/>l.output[obj_index];</highlight></codeline>
<codeline lineno="206"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//l.delta[obj_index]<sp/>=<sp/>l.noobject_scale<sp/>*<sp/>(0<sp/>-<sp/>l.output[obj_index]);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="207"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>p<sp/>=<sp/>scale*get_hierarchy_probability(l.output<sp/>+<sp/>class_index,<sp/>l.softmax_tree,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal">,<sp/>l.w*l.h);</highlight></codeline>
<codeline lineno="208"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(p<sp/>&gt;<sp/>maxp){</highlight></codeline>
<codeline lineno="209"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>maxp<sp/>=<sp/>p;</highlight></codeline>
<codeline lineno="210"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>maxi<sp/>=<sp/>n;</highlight></codeline>
<codeline lineno="211"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="212"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="213"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>class_index<sp/>=<sp/>entry_index(l,<sp/>b,<sp/>maxi,<sp/>l.coords<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="214"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>obj_index<sp/>=<sp/>entry_index(l,<sp/>b,<sp/>maxi,<sp/>l.coords);</highlight></codeline>
<codeline lineno="215"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>delta_region_class(l.output,<sp/>l.delta,<sp/>class_index,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal">,<sp/>l.classes,<sp/>l.softmax_tree,<sp/>l.class_scale,<sp/>l.w*l.h,<sp/>&amp;avg_cat);</highlight></codeline>
<codeline lineno="216"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//if(l.output[obj_index]<sp/>&lt;<sp/>.3)<sp/>l.delta[obj_index]<sp/>=<sp/>l.object_scale<sp/>*<sp/>(.3<sp/>-<sp/>l.output[obj_index]);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="217"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//else<sp/><sp/>l.delta[obj_index]<sp/>=<sp/>0;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="218"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>l.delta[obj_index]<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="219"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++class_count;</highlight></codeline>
<codeline lineno="220"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>onlyclass<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="221"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="222"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="223"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="224"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(onlyclass)<sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="225"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="226"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>l.h;<sp/>++j)<sp/>{</highlight></codeline>
<codeline lineno="227"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>l.w;<sp/>++i)<sp/>{</highlight></codeline>
<codeline lineno="228"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(n<sp/>=<sp/>0;<sp/>n<sp/>&lt;<sp/>l.n;<sp/>++n)<sp/>{</highlight></codeline>
<codeline lineno="229"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>box_index<sp/>=<sp/>entry_index(l,<sp/>b,<sp/>n*l.w*l.h<sp/>+<sp/>j*l.w<sp/>+<sp/>i,<sp/>0);</highlight></codeline>
<codeline lineno="230"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structbox" kindref="compound">box</ref><sp/>pred<sp/>=<sp/>get_region_box(l.output,<sp/>l.biases,<sp/>n,<sp/>box_index,<sp/>i,<sp/>j,<sp/>l.w,<sp/>l.h,<sp/>l.w*l.h);</highlight></codeline>
<codeline lineno="231"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>best_iou<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="232"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(t<sp/>=<sp/>0;<sp/>t<sp/>&lt;<sp/>30;<sp/>++t){</highlight></codeline>
<codeline lineno="233"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structbox" kindref="compound">box</ref><sp/>truth<sp/>=<sp/>float_to_box(net.truth<sp/>+<sp/>t*(l.coords<sp/>+<sp/>1)<sp/>+<sp/>b*l.truths,<sp/>1);</highlight></codeline>
<codeline lineno="234"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!truth.x)<sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="235"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>iou<sp/>=<sp/>box_iou(pred,<sp/>truth);</highlight></codeline>
<codeline lineno="236"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iou<sp/>&gt;<sp/>best_iou)<sp/>{</highlight></codeline>
<codeline lineno="237"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>best_iou<sp/>=<sp/>iou;</highlight></codeline>
<codeline lineno="238"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="239"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="240"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>obj_index<sp/>=<sp/>entry_index(l,<sp/>b,<sp/>n*l.w*l.h<sp/>+<sp/>j*l.w<sp/>+<sp/>i,<sp/>l.coords);</highlight></codeline>
<codeline lineno="241"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>avg_anyobj<sp/>+=<sp/>l.output[obj_index];</highlight></codeline>
<codeline lineno="242"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>l.delta[obj_index]<sp/>=<sp/>l.noobject_scale<sp/>*<sp/>(0<sp/>-<sp/>l.output[obj_index]);</highlight></codeline>
<codeline lineno="243"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(l.background)<sp/>l.delta[obj_index]<sp/>=<sp/>l.noobject_scale<sp/>*<sp/>(1<sp/>-<sp/>l.output[obj_index]);</highlight></codeline>
<codeline lineno="244"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(best_iou<sp/>&gt;<sp/>l.thresh)<sp/>{</highlight></codeline>
<codeline lineno="245"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>l.delta[obj_index]<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="246"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="247"><highlight class="normal"></highlight></codeline>
<codeline lineno="248"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(*(net.seen)<sp/>&lt;<sp/>12800){</highlight></codeline>
<codeline lineno="249"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structbox" kindref="compound">box</ref><sp/>truth<sp/>=<sp/>{0};</highlight></codeline>
<codeline lineno="250"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>truth.x<sp/>=<sp/>(i<sp/>+<sp/>.5)/l.w;</highlight></codeline>
<codeline lineno="251"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>truth.y<sp/>=<sp/>(j<sp/>+<sp/>.5)/l.h;</highlight></codeline>
<codeline lineno="252"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>truth.w<sp/>=<sp/>l.biases[2*n]/l.w;</highlight></codeline>
<codeline lineno="253"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>truth.h<sp/>=<sp/>l.biases[2*n+1]/l.h;</highlight></codeline>
<codeline lineno="254"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>delta_region_box(truth,<sp/>l.output,<sp/>l.biases,<sp/>n,<sp/>box_index,<sp/>i,<sp/>j,<sp/>l.w,<sp/>l.h,<sp/>l.delta,<sp/>.01,<sp/>l.w*l.h);</highlight></codeline>
<codeline lineno="255"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="256"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="257"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="258"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="259"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(t<sp/>=<sp/>0;<sp/>t<sp/>&lt;<sp/>30;<sp/>++t){</highlight></codeline>
<codeline lineno="260"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structbox" kindref="compound">box</ref><sp/>truth<sp/>=<sp/>float_to_box(net.truth<sp/>+<sp/>t*(l.coords<sp/>+<sp/>1)<sp/>+<sp/>b*l.truths,<sp/>1);</highlight></codeline>
<codeline lineno="261"><highlight class="normal"></highlight></codeline>
<codeline lineno="262"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!truth.x)<sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="263"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>best_iou<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="264"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>best_n<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="265"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>(truth.x<sp/>*<sp/>l.w);</highlight></codeline>
<codeline lineno="266"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>j<sp/>=<sp/>(truth.y<sp/>*<sp/>l.h);</highlight></codeline>
<codeline lineno="267"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//printf(&quot;%d<sp/>%f<sp/>%d<sp/>%f\n&quot;,<sp/>i,<sp/>truth.x*l.w,<sp/>j,<sp/>truth.y*l.h);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="268"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structbox" kindref="compound">box</ref><sp/>truth_shift<sp/>=<sp/>truth;</highlight></codeline>
<codeline lineno="269"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>truth_shift.x<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="270"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>truth_shift.y<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="271"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//printf(&quot;index<sp/>%d<sp/>%d\n&quot;,i,<sp/>j);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="272"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(n<sp/>=<sp/>0;<sp/>n<sp/>&lt;<sp/>l.n;<sp/>++n){</highlight></codeline>
<codeline lineno="273"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>box_index<sp/>=<sp/>entry_index(l,<sp/>b,<sp/>n*l.w*l.h<sp/>+<sp/>j*l.w<sp/>+<sp/>i,<sp/>0);</highlight></codeline>
<codeline lineno="274"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structbox" kindref="compound">box</ref><sp/>pred<sp/>=<sp/>get_region_box(l.output,<sp/>l.biases,<sp/>n,<sp/>box_index,<sp/>i,<sp/>j,<sp/>l.w,<sp/>l.h,<sp/>l.w*l.h);</highlight></codeline>
<codeline lineno="275"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(l.bias_match){</highlight></codeline>
<codeline lineno="276"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pred.w<sp/>=<sp/>l.biases[2*n]/l.w;</highlight></codeline>
<codeline lineno="277"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pred.h<sp/>=<sp/>l.biases[2*n+1]/l.h;</highlight></codeline>
<codeline lineno="278"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="279"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//printf(&quot;pred:<sp/>(%f,<sp/>%f)<sp/>%f<sp/>x<sp/>%f\n&quot;,<sp/>pred.x,<sp/>pred.y,<sp/>pred.w,<sp/>pred.h);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="280"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pred.x<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="281"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pred.y<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="282"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>iou<sp/>=<sp/>box_iou(pred,<sp/>truth_shift);</highlight></codeline>
<codeline lineno="283"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iou<sp/>&gt;<sp/>best_iou){</highlight></codeline>
<codeline lineno="284"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>best_iou<sp/>=<sp/>iou;</highlight></codeline>
<codeline lineno="285"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>best_n<sp/>=<sp/>n;</highlight></codeline>
<codeline lineno="286"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="287"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="288"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//printf(&quot;%d<sp/>%f<sp/>(%f,<sp/>%f)<sp/>%f<sp/>x<sp/>%f\n&quot;,<sp/>best_n,<sp/>best_iou,<sp/>truth.x,<sp/>truth.y,<sp/>truth.w,<sp/>truth.h);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="289"><highlight class="normal"></highlight></codeline>
<codeline lineno="290"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>box_index<sp/>=<sp/>entry_index(l,<sp/>b,<sp/>best_n*l.w*l.h<sp/>+<sp/>j*l.w<sp/>+<sp/>i,<sp/>0);</highlight></codeline>
<codeline lineno="291"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>iou<sp/>=<sp/>delta_region_box(truth,<sp/>l.output,<sp/>l.biases,<sp/>best_n,<sp/>box_index,<sp/>i,<sp/>j,<sp/>l.w,<sp/>l.h,<sp/>l.delta,<sp/>l.coord_scale<sp/>*<sp/><sp/>(2<sp/>-<sp/>truth.w*truth.h),<sp/>l.w*l.h);</highlight></codeline>
<codeline lineno="292"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(l.coords<sp/>&gt;<sp/>4){</highlight></codeline>
<codeline lineno="293"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>mask_index<sp/>=<sp/>entry_index(l,<sp/>b,<sp/>best_n*l.w*l.h<sp/>+<sp/>j*l.w<sp/>+<sp/>i,<sp/>4);</highlight></codeline>
<codeline lineno="294"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>delta_region_mask(net.truth<sp/>+<sp/>t*(l.coords<sp/>+<sp/>1)<sp/>+<sp/>b*l.truths<sp/>+<sp/>5,<sp/>l.output,<sp/>l.coords<sp/>-<sp/>4,<sp/>mask_index,<sp/>l.delta,<sp/>l.w*l.h,<sp/>l.mask_scale);</highlight></codeline>
<codeline lineno="295"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="296"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(iou<sp/>&gt;<sp/>.5)<sp/>recall<sp/>+=<sp/>1;</highlight></codeline>
<codeline lineno="297"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>avg_iou<sp/>+=<sp/>iou;</highlight></codeline>
<codeline lineno="298"><highlight class="normal"></highlight></codeline>
<codeline lineno="299"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//l.delta[best_index<sp/>+<sp/>4]<sp/>=<sp/>iou<sp/>-<sp/>l.output[best_index<sp/>+<sp/>4];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="300"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>obj_index<sp/>=<sp/>entry_index(l,<sp/>b,<sp/>best_n*l.w*l.h<sp/>+<sp/>j*l.w<sp/>+<sp/>i,<sp/>l.coords);</highlight></codeline>
<codeline lineno="301"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>avg_obj<sp/>+=<sp/>l.output[obj_index];</highlight></codeline>
<codeline lineno="302"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>l.delta[obj_index]<sp/>=<sp/>l.object_scale<sp/>*<sp/>(1<sp/>-<sp/>l.output[obj_index]);</highlight></codeline>
<codeline lineno="303"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(l.rescore)<sp/>{</highlight></codeline>
<codeline lineno="304"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>l.delta[obj_index]<sp/>=<sp/>l.object_scale<sp/>*<sp/>(iou<sp/>-<sp/>l.output[obj_index]);</highlight></codeline>
<codeline lineno="305"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="306"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(l.background){</highlight></codeline>
<codeline lineno="307"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>l.delta[obj_index]<sp/>=<sp/>l.object_scale<sp/>*<sp/>(0<sp/>-<sp/>l.output[obj_index]);</highlight></codeline>
<codeline lineno="308"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="309"><highlight class="normal"></highlight></codeline>
<codeline lineno="310"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">=<sp/>net.truth[t*(l.coords<sp/>+<sp/>1)<sp/>+<sp/>b*l.truths<sp/>+<sp/>l.coords];</highlight></codeline>
<codeline lineno="311"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(l.map)<sp/>class<sp/>=<sp/>l.map[class];</highlight></codeline>
<codeline lineno="312"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>class_index<sp/>=<sp/>entry_index(l,<sp/>b,<sp/>best_n*l.w*l.h<sp/>+<sp/>j*l.w<sp/>+<sp/>i,<sp/>l.coords<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="313"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>delta_region_class(l.output,<sp/>l.delta,<sp/>class_index,<sp/>class,<sp/>l.classes,<sp/>l.softmax_tree,<sp/>l.class_scale,<sp/>l.w*l.h,<sp/>&amp;avg_cat);</highlight></codeline>
<codeline lineno="314"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++count;</highlight></codeline>
<codeline lineno="315"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++class_count;</highlight></codeline>
<codeline lineno="316"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="317"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="318"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//printf(&quot;\n&quot;);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="319"><highlight class="normal"><sp/><sp/><sp/><sp/>*(l.cost)<sp/>=<sp/>pow(mag_array(l.delta,<sp/>l.outputs<sp/>*<sp/>l.batch),<sp/>2);</highlight></codeline>
<codeline lineno="320"><highlight class="normal"><sp/><sp/><sp/><sp/>printf(&quot;Region<sp/>Avg<sp/>IOU:<sp/>%f,<sp/>Class:<sp/>%f,<sp/>Obj:<sp/>%f,<sp/>No<sp/>Obj:<sp/>%f,<sp/>Avg<sp/>Recall:<sp/>%f,<sp/><sp/>count:<sp/>%d\n&quot;,<sp/>avg_iou/count,<sp/>avg_cat/class_count,<sp/>avg_obj/count,<sp/>avg_anyobj/(l.w*l.h*l.n*l.batch),<sp/>recall/count,<sp/>count);</highlight></codeline>
<codeline lineno="321"><highlight class="normal">}</highlight></codeline>
<codeline lineno="322"><highlight class="normal"></highlight></codeline>
<codeline lineno="323"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>backward_region_layer(const<sp/><ref refid="structlayer" kindref="compound">layer</ref><sp/>l,<sp/><ref refid="structnetwork" kindref="compound">network</ref><sp/>net)</highlight></codeline>
<codeline lineno="324"><highlight class="normal">{</highlight></codeline>
<codeline lineno="325"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="326"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>b;</highlight></codeline>
<codeline lineno="327"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>size<sp/>=<sp/>l.coords<sp/>+<sp/>l.classes<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="328"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(b<sp/>=<sp/>0;<sp/>b<sp/>&lt;<sp/>l.batch*l.n;<sp/>++b){</highlight></codeline>
<codeline lineno="329"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>index<sp/>=<sp/>(b*size<sp/>+<sp/>4)*l.w*l.h;</highlight></codeline>
<codeline lineno="330"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradient_array(l.output<sp/>+<sp/>index,<sp/>l.w*l.h,<sp/>LOGISTIC,<sp/>l.delta<sp/>+<sp/>index);</highlight></codeline>
<codeline lineno="331"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="332"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>axpy_cpu(l.batch*l.inputs,<sp/>1,<sp/>l.delta,<sp/>1,<sp/>net.delta,<sp/>1);</highlight></codeline>
<codeline lineno="333"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="334"><highlight class="normal">}</highlight></codeline>
<codeline lineno="335"><highlight class="normal"></highlight></codeline>
<codeline lineno="336"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>correct_region_boxes(<ref refid="structbox" kindref="compound">box</ref><sp/>*boxes,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>w,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>h,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>netw,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>neth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>relative)</highlight></codeline>
<codeline lineno="337"><highlight class="normal">{</highlight></codeline>
<codeline lineno="338"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i;</highlight></codeline>
<codeline lineno="339"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>new_w=0;</highlight></codeline>
<codeline lineno="340"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>new_h=0;</highlight></codeline>
<codeline lineno="341"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(((</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">)netw/w)<sp/>&lt;<sp/>((</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">)neth/h))<sp/>{</highlight></codeline>
<codeline lineno="342"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new_w<sp/>=<sp/>netw;</highlight></codeline>
<codeline lineno="343"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new_h<sp/>=<sp/>(h<sp/>*<sp/>netw)/w;</highlight></codeline>
<codeline lineno="344"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="345"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new_h<sp/>=<sp/>neth;</highlight></codeline>
<codeline lineno="346"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new_w<sp/>=<sp/>(w<sp/>*<sp/>neth)/h;</highlight></codeline>
<codeline lineno="347"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="348"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>n;<sp/>++i){</highlight></codeline>
<codeline lineno="349"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structbox" kindref="compound">box</ref><sp/>b<sp/>=<sp/>boxes[i];</highlight></codeline>
<codeline lineno="350"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>b.x<sp/>=<sp/><sp/>(b.x<sp/>-<sp/>(netw<sp/>-<sp/>new_w)/2./netw)<sp/>/<sp/>((float)new_w/netw);<sp/></highlight></codeline>
<codeline lineno="351"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>b.y<sp/>=<sp/><sp/>(b.y<sp/>-<sp/>(neth<sp/>-<sp/>new_h)/2./neth)<sp/>/<sp/>((float)new_h/neth);<sp/></highlight></codeline>
<codeline lineno="352"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>b.w<sp/>*=<sp/>(float)netw/new_w;</highlight></codeline>
<codeline lineno="353"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>b.h<sp/>*=<sp/>(float)neth/new_h;</highlight></codeline>
<codeline lineno="354"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!relative){</highlight></codeline>
<codeline lineno="355"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>b.x<sp/>*=<sp/>w;</highlight></codeline>
<codeline lineno="356"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>b.w<sp/>*=<sp/>w;</highlight></codeline>
<codeline lineno="357"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>b.y<sp/>*=<sp/>h;</highlight></codeline>
<codeline lineno="358"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>b.h<sp/>*=<sp/>h;</highlight></codeline>
<codeline lineno="359"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="360"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>boxes[i]<sp/>=<sp/>b;</highlight></codeline>
<codeline lineno="361"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="362"><highlight class="normal">}</highlight></codeline>
<codeline lineno="363"><highlight class="normal"></highlight></codeline>
<codeline lineno="364"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>get_region_boxes(<ref refid="structlayer" kindref="compound">layer</ref><sp/>l,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>w,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>h,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>netw,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>neth,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>thresh,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>**probs,<sp/><ref refid="structbox" kindref="compound">box</ref><sp/>*boxes,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>**masks,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>only_objectness,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*map,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>tree_thresh,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>relative)</highlight></codeline>
<codeline lineno="365"><highlight class="normal">{</highlight></codeline>
<codeline lineno="366"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,j,n,z;</highlight></codeline>
<codeline lineno="367"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*predictions<sp/>=<sp/>l.output;</highlight></codeline>
<codeline lineno="368"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(l.batch<sp/>==<sp/>2)<sp/>{</highlight></codeline>
<codeline lineno="369"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*flip<sp/>=<sp/>l.output<sp/>+<sp/>l.outputs;</highlight></codeline>
<codeline lineno="370"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>l.h;<sp/>++j)<sp/>{</highlight></codeline>
<codeline lineno="371"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>l.w/2;<sp/>++i)<sp/>{</highlight></codeline>
<codeline lineno="372"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(n<sp/>=<sp/>0;<sp/>n<sp/>&lt;<sp/>l.n;<sp/>++n)<sp/>{</highlight></codeline>
<codeline lineno="373"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(z<sp/>=<sp/>0;<sp/>z<sp/>&lt;<sp/>l.classes<sp/>+<sp/>l.coords<sp/>+<sp/>1;<sp/>++z){</highlight></codeline>
<codeline lineno="374"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i1<sp/>=<sp/>z*l.w*l.h*l.n<sp/>+<sp/>n*l.w*l.h<sp/>+<sp/>j*l.w<sp/>+<sp/>i;</highlight></codeline>
<codeline lineno="375"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i2<sp/>=<sp/>z*l.w*l.h*l.n<sp/>+<sp/>n*l.w*l.h<sp/>+<sp/>j*l.w<sp/>+<sp/>(l.w<sp/>-<sp/>i<sp/>-<sp/>1);</highlight></codeline>
<codeline lineno="376"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>swap<sp/>=<sp/>flip[i1];</highlight></codeline>
<codeline lineno="377"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>flip[i1]<sp/>=<sp/>flip[i2];</highlight></codeline>
<codeline lineno="378"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>flip[i2]<sp/>=<sp/>swap;</highlight></codeline>
<codeline lineno="379"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(z<sp/>==<sp/>0){</highlight></codeline>
<codeline lineno="380"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>flip[i1]<sp/>=<sp/>-flip[i1];</highlight></codeline>
<codeline lineno="381"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>flip[i2]<sp/>=<sp/>-flip[i2];</highlight></codeline>
<codeline lineno="382"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="383"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="384"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="385"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="386"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="387"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>l.outputs;<sp/>++i){</highlight></codeline>
<codeline lineno="388"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>l.output[i]<sp/>=<sp/>(l.output[i]<sp/>+<sp/>flip[i])/2.;</highlight></codeline>
<codeline lineno="389"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="390"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="391"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>l.w*l.h;<sp/>++i){</highlight></codeline>
<codeline lineno="392"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>row<sp/>=<sp/>i<sp/>/<sp/>l.w;</highlight></codeline>
<codeline lineno="393"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>col<sp/>=<sp/>i<sp/>%<sp/>l.w;</highlight></codeline>
<codeline lineno="394"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(n<sp/>=<sp/>0;<sp/>n<sp/>&lt;<sp/>l.n;<sp/>++n){</highlight></codeline>
<codeline lineno="395"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>index<sp/>=<sp/>n*l.w*l.h<sp/>+<sp/>i;</highlight></codeline>
<codeline lineno="396"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>l.classes;<sp/>++j){</highlight></codeline>
<codeline lineno="397"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>probs[index][j]<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="398"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="399"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>obj_index<sp/><sp/>=<sp/>entry_index(l,<sp/>0,<sp/>n*l.w*l.h<sp/>+<sp/>i,<sp/>l.coords);</highlight></codeline>
<codeline lineno="400"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>box_index<sp/><sp/>=<sp/>entry_index(l,<sp/>0,<sp/>n*l.w*l.h<sp/>+<sp/>i,<sp/>0);</highlight></codeline>
<codeline lineno="401"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>mask_index<sp/>=<sp/>entry_index(l,<sp/>0,<sp/>n*l.w*l.h<sp/>+<sp/>i,<sp/>4);</highlight></codeline>
<codeline lineno="402"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>scale<sp/>=<sp/>l.background<sp/>?<sp/>1<sp/>:<sp/>predictions[obj_index];</highlight></codeline>
<codeline lineno="403"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>boxes[index]<sp/>=<sp/>get_region_box(predictions,<sp/>l.biases,<sp/>n,<sp/>box_index,<sp/>col,<sp/>row,<sp/>l.w,<sp/>l.h,<sp/>l.w*l.h);</highlight></codeline>
<codeline lineno="404"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(masks){</highlight></codeline>
<codeline lineno="405"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>l.coords<sp/>-<sp/>4;<sp/>++j){</highlight></codeline>
<codeline lineno="406"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>masks[index][j]<sp/>=<sp/>l.output[mask_index<sp/>+<sp/>j*l.w*l.h];</highlight></codeline>
<codeline lineno="407"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="408"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="409"><highlight class="normal"></highlight></codeline>
<codeline lineno="410"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>class_index<sp/>=<sp/>entry_index(l,<sp/>0,<sp/>n*l.w*l.h<sp/>+<sp/>i,<sp/>l.coords<sp/>+<sp/>!l.background);</highlight></codeline>
<codeline lineno="411"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(l.softmax_tree){</highlight></codeline>
<codeline lineno="412"><highlight class="normal"></highlight></codeline>
<codeline lineno="413"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>hierarchy_predictions(predictions<sp/>+<sp/>class_index,<sp/>l.classes,<sp/>l.softmax_tree,<sp/>0,<sp/>l.w*l.h);</highlight></codeline>
<codeline lineno="414"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(map){</highlight></codeline>
<codeline lineno="415"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>200;<sp/>++j){</highlight></codeline>
<codeline lineno="416"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>class_index<sp/>=<sp/>entry_index(l,<sp/>0,<sp/>n*l.w*l.h<sp/>+<sp/>i,<sp/>l.coords<sp/>+<sp/>1<sp/>+<sp/>map[j]);</highlight></codeline>
<codeline lineno="417"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>prob<sp/>=<sp/>scale*predictions[class_index];</highlight></codeline>
<codeline lineno="418"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>probs[index][j]<sp/>=<sp/>(prob<sp/>&gt;<sp/>thresh)<sp/>?<sp/>prob<sp/>:<sp/>0;</highlight></codeline>
<codeline lineno="419"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="420"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="421"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/><sp/>hierarchy_top_prediction(predictions<sp/>+<sp/>class_index,<sp/>l.softmax_tree,<sp/>tree_thresh,<sp/>l.w*l.h);</highlight></codeline>
<codeline lineno="422"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>probs[index][j]<sp/>=<sp/>(scale<sp/>&gt;<sp/>thresh)<sp/>?<sp/>scale<sp/>:<sp/>0;</highlight></codeline>
<codeline lineno="423"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>probs[index][l.classes]<sp/>=<sp/>scale;</highlight></codeline>
<codeline lineno="424"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="425"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="426"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>max<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="427"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>l.classes;<sp/>++j){</highlight></codeline>
<codeline lineno="428"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>class_index<sp/>=<sp/>entry_index(l,<sp/>0,<sp/>n*l.w*l.h<sp/>+<sp/>i,<sp/>l.coords<sp/>+<sp/>1<sp/>+<sp/>j);</highlight></codeline>
<codeline lineno="429"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>prob<sp/>=<sp/>scale*predictions[class_index];</highlight></codeline>
<codeline lineno="430"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>probs[index][j]<sp/>=<sp/>(prob<sp/>&gt;<sp/>thresh)<sp/>?<sp/>prob<sp/>:<sp/>0;</highlight></codeline>
<codeline lineno="431"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(prob<sp/>&gt;<sp/>max)<sp/>max<sp/>=<sp/>prob;</highlight></codeline>
<codeline lineno="432"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>TODO<sp/>REMOVE</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="433"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>if<sp/>(j<sp/>==<sp/>56<sp/>)<sp/>probs[index][j]<sp/>=<sp/>0;<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="434"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="435"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(j<sp/>!=<sp/>0)<sp/>probs[index][j]<sp/>=<sp/>0;<sp/></highlight></codeline>
<codeline lineno="436"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>blacklist[]<sp/>=<sp/>{121,<sp/>497,<sp/>482,<sp/>504,<sp/>122,<sp/>518,481,<sp/>418,<sp/>542,<sp/>491,<sp/>914,<sp/>478,<sp/>120,<sp/>510,500};</highlight></codeline>
<codeline lineno="437"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>bb;</highlight></codeline>
<codeline lineno="438"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(bb<sp/>=<sp/>0;<sp/>bb<sp/>&lt;<sp/>sizeof(blacklist)/sizeof(int);<sp/>++bb){</highlight></codeline>
<codeline lineno="439"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if(index<sp/>==<sp/>blacklist[bb])<sp/>probs[index][j]<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="440"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="441"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="442"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="443"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>probs[index][l.classes]<sp/>=<sp/>max;</highlight></codeline>
<codeline lineno="444"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="445"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(only_objectness){</highlight></codeline>
<codeline lineno="446"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>probs[index][0]<sp/>=<sp/>scale;</highlight></codeline>
<codeline lineno="447"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="448"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="449"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="450"><highlight class="normal"><sp/><sp/><sp/><sp/>correct_region_boxes(boxes,<sp/>l.w*l.h*l.n,<sp/>w,<sp/>h,<sp/>netw,<sp/>neth,<sp/>relative);</highlight></codeline>
<codeline lineno="451"><highlight class="normal">}</highlight></codeline>
<codeline lineno="452"><highlight class="normal"></highlight></codeline>
<codeline lineno="453"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>GPU</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="454"><highlight class="normal"></highlight></codeline>
<codeline lineno="455"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>forward_region_layer_gpu(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structlayer" kindref="compound">layer</ref><sp/>l,<sp/><ref refid="structnetwork" kindref="compound">network</ref><sp/>net)</highlight></codeline>
<codeline lineno="456"><highlight class="normal">{</highlight></codeline>
<codeline lineno="457"><highlight class="normal"><sp/><sp/><sp/><sp/>copy_gpu(l.batch*l.inputs,<sp/>net.input_gpu,<sp/>1,<sp/>l.output_gpu,<sp/>1);</highlight></codeline>
<codeline lineno="458"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>b,<sp/>n;</highlight></codeline>
<codeline lineno="459"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(b<sp/>=<sp/>0;<sp/>b<sp/>&lt;<sp/>l.batch;<sp/>++b){</highlight></codeline>
<codeline lineno="460"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(n<sp/>=<sp/>0;<sp/>n<sp/>&lt;<sp/>l.n;<sp/>++n){</highlight></codeline>
<codeline lineno="461"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>index<sp/>=<sp/>entry_index(l,<sp/>b,<sp/>n*l.w*l.h,<sp/>0);</highlight></codeline>
<codeline lineno="462"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>activate_array_gpu(l.output_gpu<sp/>+<sp/>index,<sp/>2*l.w*l.h,<sp/>LOGISTIC);</highlight></codeline>
<codeline lineno="463"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(l.coords<sp/>&gt;<sp/>4){</highlight></codeline>
<codeline lineno="464"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>index<sp/>=<sp/>entry_index(l,<sp/>b,<sp/>n*l.w*l.h,<sp/>4);</highlight></codeline>
<codeline lineno="465"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>activate_array_gpu(l.output_gpu<sp/>+<sp/>index,<sp/>(l.coords<sp/>-<sp/>4)*l.w*l.h,<sp/>LOGISTIC);</highlight></codeline>
<codeline lineno="466"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="467"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>index<sp/>=<sp/>entry_index(l,<sp/>b,<sp/>n*l.w*l.h,<sp/>l.coords);</highlight></codeline>
<codeline lineno="468"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!l.background)<sp/>activate_array_gpu(l.output_gpu<sp/>+<sp/>index,<sp/><sp/><sp/>l.w*l.h,<sp/>LOGISTIC);</highlight></codeline>
<codeline lineno="469"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="470"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="471"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(l.softmax_tree){</highlight></codeline>
<codeline lineno="472"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>index<sp/>=<sp/>entry_index(l,<sp/>0,<sp/>0,<sp/>l.coords<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="473"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>softmax_tree(net.input_gpu<sp/>+<sp/>index,<sp/>l.w*l.h,<sp/>l.batch*l.n,<sp/>l.inputs/l.n,<sp/>1,<sp/>l.output_gpu<sp/>+<sp/>index,<sp/>*l.softmax_tree);</highlight></codeline>
<codeline lineno="474"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="475"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>mmin<sp/>=<sp/>9000;</highlight></codeline>
<codeline lineno="476"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>mmax<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="477"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>i;</highlight></codeline>
<codeline lineno="478"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>l.softmax_tree-&gt;groups;<sp/>++i){</highlight></codeline>
<codeline lineno="479"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>group_size<sp/>=<sp/>l.softmax_tree-&gt;group_size[i];</highlight></codeline>
<codeline lineno="480"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(group_size<sp/>&lt;<sp/>mmin)<sp/>mmin<sp/>=<sp/>group_size;</highlight></codeline>
<codeline lineno="481"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(group_size<sp/>&gt;<sp/>mmax)<sp/>mmax<sp/>=<sp/>group_size;</highlight></codeline>
<codeline lineno="482"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="483"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//printf(&quot;%d<sp/>%d<sp/>%d<sp/>\n&quot;,<sp/>l.softmax_tree-&gt;groups,<sp/>mmin,<sp/>mmax);</highlight></codeline>
<codeline lineno="484"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="485"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="486"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>TIMING<sp/>CODE</highlight></codeline>
<codeline lineno="487"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>zz;</highlight></codeline>
<codeline lineno="488"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>number<sp/>=<sp/>1000;</highlight></codeline>
<codeline lineno="489"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>count<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="490"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>i;</highlight></codeline>
<codeline lineno="491"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>l.softmax_tree-&gt;groups;<sp/>++i)<sp/>{</highlight></codeline>
<codeline lineno="492"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>group_size<sp/>=<sp/>l.softmax_tree-&gt;group_size[i];</highlight></codeline>
<codeline lineno="493"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>count<sp/>+=<sp/>group_size;</highlight></codeline>
<codeline lineno="494"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="495"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;%d<sp/>%d\n&quot;,<sp/>l.softmax_tree-&gt;groups,<sp/>count);</highlight></codeline>
<codeline lineno="496"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="497"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>then<sp/>=<sp/>what_time_is_it_now();</highlight></codeline>
<codeline lineno="498"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for(zz<sp/>=<sp/>0;<sp/>zz<sp/>&lt;<sp/>number;<sp/>++zz){</highlight></codeline>
<codeline lineno="499"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>index<sp/>=<sp/>entry_index(l,<sp/>0,<sp/>0,<sp/>5);</highlight></codeline>
<codeline lineno="500"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>softmax_tree(net.input_gpu<sp/>+<sp/>index,<sp/>l.w*l.h,<sp/>l.batch*l.n,<sp/>l.inputs/l.n,<sp/>1,<sp/>l.output_gpu<sp/>+<sp/>index,<sp/>*l.softmax_tree);</highlight></codeline>
<codeline lineno="501"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="502"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaDeviceSynchronize();</highlight></codeline>
<codeline lineno="503"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;Good<sp/>GPU<sp/>Timing:<sp/>%f\n&quot;,<sp/>what_time_is_it_now()<sp/>-<sp/>then);</highlight></codeline>
<codeline lineno="504"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight></codeline>
<codeline lineno="505"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="506"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>then<sp/>=<sp/>what_time_is_it_now();</highlight></codeline>
<codeline lineno="507"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for(zz<sp/>=<sp/>0;<sp/>zz<sp/>&lt;<sp/>number;<sp/>++zz){</highlight></codeline>
<codeline lineno="508"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>i;</highlight></codeline>
<codeline lineno="509"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>count<sp/>=<sp/>5;</highlight></codeline>
<codeline lineno="510"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>l.softmax_tree-&gt;groups;<sp/>++i)<sp/>{</highlight></codeline>
<codeline lineno="511"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>group_size<sp/>=<sp/>l.softmax_tree-&gt;group_size[i];</highlight></codeline>
<codeline lineno="512"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>index<sp/>=<sp/>entry_index(l,<sp/>0,<sp/>0,<sp/>count);</highlight></codeline>
<codeline lineno="513"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>softmax_gpu(net.input_gpu<sp/>+<sp/>index,<sp/>group_size,<sp/>l.batch*l.n,<sp/>l.inputs/l.n,<sp/>l.w*l.h,<sp/>1,<sp/>l.w*l.h,<sp/>1,<sp/>l.output_gpu<sp/>+<sp/>index);</highlight></codeline>
<codeline lineno="514"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>count<sp/>+=<sp/>group_size;</highlight></codeline>
<codeline lineno="515"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="516"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="517"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaDeviceSynchronize();</highlight></codeline>
<codeline lineno="518"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;Bad<sp/>GPU<sp/>Timing:<sp/>%f\n&quot;,<sp/>what_time_is_it_now()<sp/>-<sp/>then);</highlight></codeline>
<codeline lineno="519"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="520"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="521"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>then<sp/>=<sp/>what_time_is_it_now();</highlight></codeline>
<codeline lineno="522"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for(zz<sp/>=<sp/>0;<sp/>zz<sp/>&lt;<sp/>number;<sp/>++zz){</highlight></codeline>
<codeline lineno="523"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>i;</highlight></codeline>
<codeline lineno="524"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>count<sp/>=<sp/>5;</highlight></codeline>
<codeline lineno="525"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>l.softmax_tree-&gt;groups;<sp/>++i)<sp/>{</highlight></codeline>
<codeline lineno="526"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>group_size<sp/>=<sp/>l.softmax_tree-&gt;group_size[i];</highlight></codeline>
<codeline lineno="527"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>softmax_cpu(net.input<sp/>+<sp/>count,<sp/>group_size,<sp/>l.batch,<sp/>l.inputs,<sp/>l.n*l.w*l.h,<sp/>1,<sp/>l.n*l.w*l.h,<sp/>l.temperature,<sp/>l.output<sp/>+<sp/>count);</highlight></codeline>
<codeline lineno="528"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>count<sp/>+=<sp/>group_size;</highlight></codeline>
<codeline lineno="529"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="530"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="531"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaDeviceSynchronize();</highlight></codeline>
<codeline lineno="532"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;CPU<sp/>Timing:<sp/>%f\n&quot;,<sp/>what_time_is_it_now()<sp/>-<sp/>then);</highlight></codeline>
<codeline lineno="533"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="534"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="535"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="536"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>i;</highlight></codeline>
<codeline lineno="537"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>count<sp/>=<sp/>5;</highlight></codeline>
<codeline lineno="538"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>l.softmax_tree-&gt;groups;<sp/>++i)<sp/>{</highlight></codeline>
<codeline lineno="539"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>group_size<sp/>=<sp/>l.softmax_tree-&gt;group_size[i];</highlight></codeline>
<codeline lineno="540"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>index<sp/>=<sp/>entry_index(l,<sp/>0,<sp/>0,<sp/>count);</highlight></codeline>
<codeline lineno="541"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>softmax_gpu(net.input_gpu<sp/>+<sp/>index,<sp/>group_size,<sp/>l.batch*l.n,<sp/>l.inputs/l.n,<sp/>l.w*l.h,<sp/>1,<sp/>l.w*l.h,<sp/>1,<sp/>l.output_gpu<sp/>+<sp/>index);</highlight></codeline>
<codeline lineno="542"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>count<sp/>+=<sp/>group_size;</highlight></codeline>
<codeline lineno="543"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="544"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="545"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(l.softmax)<sp/>{</highlight></codeline>
<codeline lineno="546"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>index<sp/>=<sp/>entry_index(l,<sp/>0,<sp/>0,<sp/>l.coords<sp/>+<sp/>!l.background);</highlight></codeline>
<codeline lineno="547"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//printf(&quot;%d\n&quot;,<sp/>index);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="548"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>softmax_gpu(net.input_gpu<sp/>+<sp/>index,<sp/>l.classes<sp/>+<sp/>l.background,<sp/>l.batch*l.n,<sp/>l.inputs/l.n,<sp/>l.w*l.h,<sp/>1,<sp/>l.w*l.h,<sp/>1,<sp/>l.output_gpu<sp/>+<sp/>index);</highlight></codeline>
<codeline lineno="549"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="550"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!net.train<sp/>||<sp/>l.onlyforward){</highlight></codeline>
<codeline lineno="551"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cuda_pull_array(l.output_gpu,<sp/>l.output,<sp/>l.batch*l.outputs);</highlight></codeline>
<codeline lineno="552"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="553"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="554"><highlight class="normal"></highlight></codeline>
<codeline lineno="555"><highlight class="normal"><sp/><sp/><sp/><sp/>cuda_pull_array(l.output_gpu,<sp/>net.input,<sp/>l.batch*l.inputs);</highlight></codeline>
<codeline lineno="556"><highlight class="normal"><sp/><sp/><sp/><sp/>forward_region_layer(l,<sp/>net);</highlight></codeline>
<codeline lineno="557"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//cuda_push_array(l.output_gpu,<sp/>l.output,<sp/>l.batch*l.outputs);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="558"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!net.train)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="559"><highlight class="normal"><sp/><sp/><sp/><sp/>cuda_push_array(l.delta_gpu,<sp/>l.delta,<sp/>l.batch*l.outputs);</highlight></codeline>
<codeline lineno="560"><highlight class="normal">}</highlight></codeline>
<codeline lineno="561"><highlight class="normal"></highlight></codeline>
<codeline lineno="562"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>backward_region_layer_gpu(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structlayer" kindref="compound">layer</ref><sp/>l,<sp/><ref refid="structnetwork" kindref="compound">network</ref><sp/>net)</highlight></codeline>
<codeline lineno="563"><highlight class="normal">{</highlight></codeline>
<codeline lineno="564"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>b,<sp/>n;</highlight></codeline>
<codeline lineno="565"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(b<sp/>=<sp/>0;<sp/>b<sp/>&lt;<sp/>l.batch;<sp/>++b){</highlight></codeline>
<codeline lineno="566"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(n<sp/>=<sp/>0;<sp/>n<sp/>&lt;<sp/>l.n;<sp/>++n){</highlight></codeline>
<codeline lineno="567"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>index<sp/>=<sp/>entry_index(l,<sp/>b,<sp/>n*l.w*l.h,<sp/>0);</highlight></codeline>
<codeline lineno="568"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradient_array_gpu(l.output_gpu<sp/>+<sp/>index,<sp/>2*l.w*l.h,<sp/>LOGISTIC,<sp/>l.delta_gpu<sp/>+<sp/>index);</highlight></codeline>
<codeline lineno="569"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(l.coords<sp/>&gt;<sp/>4){</highlight></codeline>
<codeline lineno="570"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>index<sp/>=<sp/>entry_index(l,<sp/>b,<sp/>n*l.w*l.h,<sp/>4);</highlight></codeline>
<codeline lineno="571"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradient_array_gpu(l.output_gpu<sp/>+<sp/>index,<sp/>(l.coords<sp/>-<sp/>4)*l.w*l.h,<sp/>LOGISTIC,<sp/>l.delta_gpu<sp/>+<sp/>index);</highlight></codeline>
<codeline lineno="572"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="573"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>index<sp/>=<sp/>entry_index(l,<sp/>b,<sp/>n*l.w*l.h,<sp/>l.coords);</highlight></codeline>
<codeline lineno="574"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!l.background)<sp/>gradient_array_gpu(l.output_gpu<sp/>+<sp/>index,<sp/><sp/><sp/>l.w*l.h,<sp/>LOGISTIC,<sp/>l.delta_gpu<sp/>+<sp/>index);</highlight></codeline>
<codeline lineno="575"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="576"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="577"><highlight class="normal"><sp/><sp/><sp/><sp/>axpy_gpu(l.batch*l.inputs,<sp/>1,<sp/>l.delta_gpu,<sp/>1,<sp/>net.delta_gpu,<sp/>1);</highlight></codeline>
<codeline lineno="578"><highlight class="normal">}</highlight></codeline>
<codeline lineno="579"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="580"><highlight class="normal"></highlight></codeline>
<codeline lineno="581"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>zero_objectness(<ref refid="structlayer" kindref="compound">layer</ref><sp/>l)</highlight></codeline>
<codeline lineno="582"><highlight class="normal">{</highlight></codeline>
<codeline lineno="583"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/>n;</highlight></codeline>
<codeline lineno="584"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>l.w*l.h;<sp/>++i){</highlight></codeline>
<codeline lineno="585"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(n<sp/>=<sp/>0;<sp/>n<sp/>&lt;<sp/>l.n;<sp/>++n){</highlight></codeline>
<codeline lineno="586"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>obj_index<sp/>=<sp/>entry_index(l,<sp/>0,<sp/>n*l.w*l.h<sp/>+<sp/>i,<sp/>l.coords);</highlight></codeline>
<codeline lineno="587"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>l.output[obj_index]<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="588"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="589"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="590"><highlight class="normal">}</highlight></codeline>
<codeline lineno="591"><highlight class="normal"></highlight></codeline>
    </programlisting>
    <location file="/home/ubuntu/workspace/roboy_vision/src/pyyolo/darknet/src/region_layer.c"/>
  </compounddef>
</doxygen>
